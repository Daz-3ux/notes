# 15.1 概述
- `OOP`:object-oriented programming
- 核心思想:
  - `数据抽象`
  - `继承`
  - `动态绑定`

## 继承
- 通过继承联系在一起的类构成一种`层次关系`
- 在层次关系根部有一个`基类`,其他类则直接或间接地从基类继承而来,这些继承得到的类叫做`派生类`

## 动态绑定
- 运行时绑定
- 当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定

# 15.2 定义基类和派生类
## 15.2.1 定义基类
- 基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如此

### 成员函数与继承
- 基类的两种成员函数
  - 基类希望派生类进行覆盖的函数:通常定义为`虚函数`(若基类函数被定义为虚函数,在派生类中其隐式地`也`为虚函数)
  - 基类希望派生类直接继承不要改变的函数

### 访问控制和继承
- `protected`(受保护的):**基类和和其派生类还有友元可以访问**
基类希望其派生类有权访问该成员,同时禁止其他用户访问
- `private`:**只有基类本身和友元可以访问**

## 15.2.2 定义派生类
- 在派生类对象中含有与其基类对应的组成部分
- 每个类控制它自己的成员初始化过程
- 首先初始化基类的部分,然后按照声明的顺序依次初始化派生类的成员

- `静态成员`在整个继承体系中只存在`唯一定义`
- 派生类的`声明`包含类名但不包含派生列表
- `被用作基类的类`必须`已经定义`而非仅仅声明
- 一个类不能派生它`自身`
- 防止继承的发生:在类名后加关键字`final`

## 类型转换与继承
- 可以将基类的指针或引用绑定到派生类对象上:当使用基类的引用(或指针)时,实际上不知道其绑定对象的真实类型
- 静态类型与动态类型
  - 静态类型在编译时总是已知
  - 动态类型在运行时才可知

- 重要三点
1. 从派生类到基类的类型转换只对`指针`或`引用`类型有效
2. 基类向派生类不存在隐式类型转换
3. 派生类向基类的类型转换可能因为访问受限而变得不可行

# 15.3 虚函数
- 必须为每一个虚函数都提供定义,而不管它是否有被用到

## `final` 和 `override`说明符
- `final`:防止继承的发生
- `override`:显示说明派生类中的虚函数

- 虚函数也可以拥有默认实参

# 15.4 抽象基类
## 纯虚函数
- 无需定义,在函数体位置书写`=0`就可以将其说明为纯虚函数
- 若想定义,则必须定义在类的外部

## 含有纯虚函数的类是`抽象基类`
- 抽象基类只负责定义接口,后续其他类可以覆盖该接口
- 不能创建抽象基类的`对象`

# 15.5 访问控制和继承
- `protected`
  - 对于类的成员来说是不可访问的
  - 对于派生类成员和友元是可访问的
  - 派生类的成员或右元只能通过`派生类对象`来访问基类的受保护成员,派生类对于一个基类对象中的受保护成员没有任何访问权限

- 友元关系不可继承

- 派生类可以为它可以访问的名字提供using声明,来改变个别成员的可访问性

# 15.6 继承中的类作用域