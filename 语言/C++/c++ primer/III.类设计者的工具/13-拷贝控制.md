# intro
- 当定义一个类时，我们显示或隐式地指定在此类型的对象拷贝、移动、赋值、销毁时干什么
- 五个特殊的成员函数：
1. 拷贝构造函数
2. 拷贝赋值运算符
3. 移动构造函数
4. 移动赋值运算符
5. 析构函数

- 如果类没有定义，那么编译器会自动为它定义缺失的操作
- 在定义任何C++类时，**拷贝控制操作都是必要部分**,如果我们自己不定义上述五种操作，那么编译器就会为我们定义（不一定符合我们的需求）

# 13.1 拷贝 赋值 销毁
## 13.1.1 拷贝构造函数
- `第一个参数为自身类 类型 的引用`,且`任何额外参数都有默认值` 的 **构造函数**
- 拷贝构造函数`通常`不应该是 `explicit`(抑制构造函数定义的隐式转换) 的

- `合成拷贝构造函数`
    - 如果我们没有定义,那么编译器会自动定义一个(不同于默认构造函数,即使我们定义了其他构造函数,编译器也会为我们合成一个拷贝构造函数)
    - 一般是编译器`合成的`拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象

- `拷贝初始化`
    - 拷贝初始化`通常`是使用拷贝构造函数来完成
    - 拷贝初始化发生的情况:
1. 使用`=`定义变量
2. 将一个对象做为实参传递给一个`非引用类型`的实参
3. 从一个返回类型为`非引用类型`的函数返回一个对象
4. **用花括号列表初始化一个数组中的元素或一个聚合类的成员**

- 某些类类型还会对他们分配的对象进行拷贝初始化
    - `初始化`标准容器 / 调用 `insert` / `push`成员:进行**拷贝初始化**
    - 使用emplace成员创建的元素:**直接初始化**

- 参数和返回值
    - 参数:必须是一个引用,要不然无限递归
    - 返回值:当一个函数具有非引用的返回类型时,返回值会被用来初始化调用方的结果

- 编译器可以绕过拷贝构造函数
    - 即使编译器`略过`了拷贝构造函数,但在这个程序点上,`拷贝/移动`构造函数必须是存在且可访问的(例如不能是private)

- 所以,拷贝构造函数是什么,什么时候使用它?
  - 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数
  - 当使用拷贝初始化时，我们会用到拷贝构造函数
```c++
Point global;
Point foo_bar(Point arg) // 1
{
	Point local = arg, *heap = new Point(global); // 2: Point local = arg,  3: Point *heap = new Point(global) 
	*heap = local; 
	Point pa[4] = { local, *heap }; // 4, 5
	return *heap;  // 6
}
```

## 13.1.2 拷贝赋值运算符
- 与类控制其对象如何初始化一样,类也可以控制其对象如何赋值

- 与处理拷贝构造函数一样,如果一个类未定义自己的拷贝复制运算符,编译器会为它生成一个`合成拷贝赋值运算符`

- 拷贝赋值运算符是什么？什么时候使用它？合成拷贝赋值运算符完成什么工作？什么时候会生成合成拷贝赋值运算符？
  - 是一个名为`operator=`的函数
  - 当赋值运算发生时就会用到它
  - 合成拷贝构造运算符可以用来禁止该类型对象的赋值
  - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符

## 13.1.3 析构函数
- 释放对象所使用的资源,并且销毁对象的非static数据成员
- 无返回值,也不接受参数

- 析构函数是什么？合成析构函数完成什么工作？什么时候会生成合成析构函数？
  - 析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数
  - 合成析构函数可被用来阻止该类型的对象被销毁
  - 当一个类未定义自己的析构函数时，编译器会为它生成一个合成析构函数

## 13.1.4 三/五法则
- `三个基本操作`可以控制类的`拷贝`操作:
  - 拷贝构造函数
  - 拷贝赋值运算符
  - 析构函数

## 13.1.5 使用=default
- 可以通过将拷贝控制成员定义为`=default`来显示地要求编译器生成合成的版本
- 当我们在类内使用=default修饰成员的声明时,合成的函数将`隐式地`声明为内联的

## 13.1.6 阻止拷贝
- 有时需要一种机制来`阻止`拷贝或赋值
- 定义删除的函数
  - `=delete`
  - 作用为用通知编译器(及代码阅读者)我们不希望定义这些成员

- 析构函数不能是删除的成员

- 合成的拷贝控制成员可能是删除的
  - 本质上,当不可能拷贝,赋值或销毁类的成员时,类的合成拷贝控制成员就被定义为`删除的`

# 13.2 拷贝控制和资源管理
- 可以定义拷贝操作,使类的行为像一个`值`或者像一个`指针`
  - 值:string
  - 指针:shared_ptr

# 13.3 交换操作
- 除了定义拷贝控制成员,管理资源的类通常还定义一个名为`swap`的函数
- 并不是必要的,但对分配了资源的类很有用

# 13.4 拷贝控制示例

# 13.5 动态内存管理

# 13.6 对象移动
- 在某些对象拷贝后就立刻销毁的情况下,移动而非拷贝对象会大幅度提升性能

## 13.6.1 右值引用
- 其就是必须绑定到右值的引用
- 通过`&&`获得
- 只能绑定到一个将要销毁的对象
- `常规引用(左值引用)`:我们不能将其绑定到要求转换的表达式,字面常量或返回右值的表达式
  - 对于右值,我们可以将其绑定到这类表达式上,但不能将其绑定到一个左值上

### 左值持久;右值短暂
- 左值具有持久的状态
  - `变量是左值`:可以将变量看作一个运算对象而没有运算符的表达式
- 右值要么是字面常量,要么是在表达式求值过程中创建的临时对象
  - 其所引用的对象即将要被销毁
  - 该对象没有其他用户
  - 意味着:`使用右值引用的代码可以自由的接管所引用的对象的资源`

### 标准库move函数
- 获取绑定到左值上的右值引用
- 告诉编译器:我们想像处理一个右值那样处理一个`左值`,承诺我们除了对其赋值和销毁之外,不再使用其
- 在调用move之后,**我们不能对移后源对象做任何假设**
  - 可以赋值,销毁,但不能再使用

## 13.6.2 移动构造函数和移动赋值运算符