## 行锁
- MyISAM 不支持行锁
- InnoDB `支持`

## 两阶段锁
- 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议
- 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放

## 死锁和死锁检测
- 出现死锁后两种策略
  - 直接进入等待,超时参数由`innodb_lock_wait_timeout`控制
  - 发起死锁检测,主动回滚死锁链条中的某一个事务,让其他事务得以继续执行,将参数`innodb_deadlock_detect`设置为`on`即可

- 怎么解决由这种热点行更新导致的性能问题呢(超多线程想更新同一行)
  - 一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉
  - 控制并发度
  - 你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理。