## 什么是微服务架构与发现
- 微服务架构下的服务注册与发现
![arch](https://static001.geekbang.org/resource/image/3d/88/3dc0cb7a9cb57a19526d305614967a88.png?wh=2238x1352)
- 服务上线
  - 服务端启动时,需要在注册中心注册自身的信息,主要是定位信息
  - 注册成功后,注册中心和服务端需要保持心跳
  - 客户端第一次发起对某个服务的调用之前,要先找注册中心获得所有可用服务节点列表,随后客户端会在本地缓存每个服务对应的可用节点列表
  - 客户端和注册中心要保持心跳和数据同步,后续服务端有任何变动,注册中心都会通知客户端,客户端会更新本地的可用节点列表
  - 客户端发送请求
  - 服务端回应

- 服务端下线
  - 服务端通知注册中心自己即将下线
  - 注册中心通知客户端某一服务端下线
  - 客户端收到通知后,新来的请求就不会再发给对应服务端
  - 服务端等待一段时间后,暂停服务并下线

## 基本模型
### 知道服务注册与发现吗 / 知道注册中心吗
- 回答服务上线与下线的具体流程
- 然后简单介绍自己使用的注册中心(etcd, ZooKeeper, Nacos)
  - 关键词是`注册数据`
- 因为提到了`主要是定位信息`,所以还要说说取决于微服务框架的功能特性的`非主要数据`
  - 非主要功能,比如`分组`(关键词是分组)
```text
服务端注册的数据除了定位信息是必需的以外，剩下需要什么数据都是根据微服务框架本身的功能和业务来设计的。
比如说很多微服务框架支持分组功能，那么就可以让服务端在注册的时候同时注册自己的分组信息，比如说当前节点是 VIP 节点。那么客户端在收到 VIP 请求之后就会把请求发给 VIP 节点
```
### 服务注册与发现的整个模型比较简单，不过要在实践中做到高可用还是很不容易的,为什么不容易?
- 关键词是`高可用`

### 高可用
- 高可用的具体实现:
  - 已注册服务端崩溃检测
  - 客户端容错
  - 注册中心选型

### 已注册服务端崩溃检测(1)
- 已注册服务端崩溃检测
  - 关键在于`如何判断服务端已经崩溃`
    - 关键词是`心跳`
    - 心跳失败立即通知 + 再试试心跳看是不是真死透了

- 引出 `如何确定重试间隔`
  - 重试间隔太大:长时间内请求都发到了死服务器
  - 无重试间隔直接重试:难以避开偶发波动,比如网就这几秒不好
  - 总会有时间误差,所以需要客户端容错

### 客户端容错(2)
- 引出 `客户端容错`
  - 客户端容错是指尽量在注册中心或者服务端节点出现问题的时候，依旧保证请求能够发送到正确的服务端节点上
  - 关键词是 `换节点 (failover)`
    - 延时怎么计算
      - 最坏的情况下，延时等于服务端和注册中心心跳间隔加上注册中心通知客户端的时间。大多数时候，注册中心通知客户端都是很快的，在毫秒级以内。因此可以认为服务端和注册中心的心跳间隔就是这个延时
    - 什么时候再将这个节点挪回可用列表
      - 注册中心发现服务端崩溃: 通知客户端不用再放回了
        - 注册中心发现恢复了再放回
      - 服务端活着+注册中心活着, 但cs之间网有问题
        - 在这种情况下，类似于注册中心和服务端心跳失败，客户端也要朝着那个疑似崩溃的服务端节点继续发送心跳。如果心跳成功了，就将节点放回可用列表。如果连续几次心跳都没有成功，那么就不用放回去了，直接认为这个节点已经崩溃了

### 注册中心选型(3)
- CAP
  - C: Consistency, 数据一致性
  - A: Availability, 服务可用性
  - P: Partition-tolerance, 分区容错性
  - 分布式系统中 CAP 三者不可兼得,只能同时满足其中两个
  - 所以核心问题就是选`AP`还是`CP` 
- 标准答案是选 `AP`
  - 可用性 + 分区容错性
  - 在选择 AP 的情况下，客户端就可能拿到错误的可用节点列表。如果客户端将请求发到错误的可用节点上，就会出现错误，此时客户端自然可以执行容错，换一个可用节点重试
  - AP 有 Eureka 和 Nacos 的 AP 模式
  - 为什么用CP?
    - 体量小,所以用了 CP 模式的 ZooKeeper


