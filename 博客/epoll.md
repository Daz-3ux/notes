# 概述
- eventpoll
- 高效：
  - 底层为`红黑树`
  - 使用`回调机制`而不是线性扫描,处理效率不会随着集合的变大而下降
  - 使用`共享内存`(内核与用户区之间),避免了频繁拷贝
- 没有最大文件描述符限制
- `线程安全`,无需进行共享资源管理

# 函数
```c
#include <sys/epoll.h>

// 创建epoll实例
int epoll_create(int size);
// 管理epoll红黑树(添加, 修改, 删除)
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
// 检测epoll树中是否有就绪的文件描述符
int epoll_wait(int epfd, struct epoll_event *event, int maxevents, int timeout);
```

# 工作模式
## 水平模式
- level trigger(`LT`)
- `默认`工作方式,支持`block`与`no-block socket`
- 通知次数多,易于编写,但效率低
- 读事件:
  - 文件描述符对应的`读缓冲区`还有`数据`,读事件就会被触发,`epoll_wait()`解除阻塞
  - 读缓冲区一次没有读完,读事件一直触发
  - 读数据是被`被动`的,必须通过读事件才知道有数据到达了,因此对于读事件的检测是`必须`的
- 写事件:
  - 如果文件描述符对应的写缓冲区可写,写事件就会被触发,epoll_wait()解除阻塞
  - 如果写缓冲区没有写满,写事件一直触发
  - 写数据是`主动`的,并且写缓冲区一般都是可写的(未满),所以对写事件的检测`不是必须`的

## 边缘触发
- edge trigger(`ET`)
- 高速工作模式,只支持`no-block socket`
- 通知次数少(`只有新事件才会通知`),编写较难,但效率高
- 读事件:
  - 当读缓冲区有新的数据进入,读事件触发`一次`,没有新数据不会触发事件
  - 如果数据没有被全部取走,`并且没有新数据进入`,读时间不会再次出发,只通知一次
  - 如果数据被全部取走或只取走一部分,`此时有新数据进入`,读事件触发,并且只通知一次
- 写事件:
  - 当写缓冲区可写,写事件只触发`一次`
  - 写缓冲区从不满到被写满,期间写事件只触发一次
  - 写缓冲区从满到不满,状态变为可写,写事件只会被触发一次

# 基于多线程的边缘非阻塞处理