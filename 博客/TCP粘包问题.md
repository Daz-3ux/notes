# 粘包问题的准确描述
- 本篇博客主要描述的是发生在客户端与服务端基于TCP的套接字通信时产生的粘包问题
    - 通信中数据的传输基于流,发送端与接收端对数据的处理数量与频率可以是不对等的,可以根据自身需求做决策
    - 也就是说在实际的传输中包长是不确定的,若想取得指定长度的包就需要程序员自己努力
- TCP是 面向连接的,安全的,流式`传输层协议`, 粘包问题的发生是由于程序的设计存在特殊的需求(比如每次处理指定数量的数据),才需要将包分开,才会存在粘包问题
- 所以粘包问题并不是TCP的设计存在缺陷

# 如何解决粘包问题
- 解决粘包问题就是`在服务端处理好客户端发来的不定长度数据包`
## 解决方案:
- 使用标准的`应用层协议(http / https)`封装要传输的不定长的数据包
- 在每条数据的尾部添加特殊字符,遇到特殊字符则代表数据接收完毕
    - 需逐字节处理,效率低
- 在发送数据块之前在数据块最前面添加一个固定大小的`数据头`,`新数据包`由`数据头`+`数据块`组成
    - 数据头:存储`数据块`的总字节数,接收端先接受`数据头`,然后再根据数据头接受相应大小的字节
    - 数据块:原始内容
![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206222152008.png)

- 数据块可能包含多种格式内容,此时可以用`JSON`来`序列化`内容,我后面会发一篇关于cJson的博客(挖坑)




