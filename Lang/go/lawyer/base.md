**https://gopl-zh.github.io/index.html**

# 入门

### 变量声明
```go
s := ""
var s string
var s = ""
var s string = ""
```
- 第一种是短变量声明，最简洁，但**只能用于函数内部，而不能用于包变量**
- 第二种依赖于字符串的默认初始化`零值机制`
- 第三种用于声明多个变量
- 第四种为了明确指出变量类型

### 迭代
- `map` 的迭代顺序并不确定，顺序为随机的，每次运行都会变化
  - 有意为之
  - 防止程序依赖特定遍历顺序

# 程序结构
- 命名: `驼峰式`

- 声明: 在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问

- 变量
  - 简短类型声明: 
    - `:=`
    - 变量声明语句
    - 变量的类型来自于自动推导
    - 广泛用于局部变量的声明和初始化
  - 指针:
    - 在Go语言中，返回函数中局部变量的地址也是安全的
  - 变量的生命周期:
    - 变量可以`逃逸`

- 赋值
  - 元组赋值
    - 允许同时更新多个变量的值
    - 赋值之前,赋值语句右边的所有表达式将会先进行求值,再统一更新左边对应变量的值

- 类型
  - 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符`大写`，则在包外部也可以使用。

- 包和文件
  - 如果一个名字是大写字母开头的，那么该名字是导出的

# 基础数据类型
- 整型
- 浮点数
- 复数
- 布尔型
- 字符串

# 复合数据类型
- 数组
  - 很少使用，而是使用切片
  - 也很少作为函数参数使用，还是使用 slice 代替
```go
// 数组字面值形式
symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

// 100 个元素，最后一位为 -1,其余均为 0
r := [...]int{99: -1}
```

- slice
  - 没有固定长度
  - 不能使用 == 来判断两个 slice 是否含有全部相等的元素
    - bytes.Equal（）函数可以判断两个字节型 slice 是否相等
  - 唯一合法的比较是和 nil 比较
  - append 函数
    - 内置函数
    - 用于向 slice 追加元素

- map
  - 无序的key/value对的集合
  - map 中的元素不是变量，不能对map的元素进行取地址操作
    - _ = &ages["bob"] 是错的!
    - 元素数量的增长可能导致map重新分配更大的空间,导致之前的地址无效
  - map 的迭代顺序是不确定的
  - 在向map存数据之前必须先创建 map

- 数组
  - 数组的顺序有意义
  - 如果要在函数内部修改结构体成员的话:必须用指针传入
    - 在 Go 中,所有的函数参值都是值拷贝传入的

# 函数
- 函数声明
  - 没有函数体的函数声明:该函数不是 Go 实现的
```go
// example
package math

func Sin(x float64) float //implemented in assembly language
```
  - 递归

  - 多返回值
    - 调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量
    - bare return: 如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数
      - 不宜过多使用

  - 错误
    - 内置的 error 是接口类型
      - error 类型可能是 nil 或 non-nil
        - `nil` 意味着函数运行成功
        - `non-nil` 表示失败
          - 可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息
          - 当函数返回non-nil的error时，其他的返回值是`未定义的`
```go
fmt.Println(err)
fmt.Printf("%v", err)
```
    - 错误处理策略
      - 最常用: 传播错误
      - 重试
      - 输出错误信息并结束程序
      - 输出错误信息但不结束程序
      - 忽略错误
    - 文件结尾错误(EOF)
      - 直接比较

- 函数值

- 匿名函数
  - `函数字面量`:可以在任何表达式中表示一个函数值
  - 函数字面量的值被称为匿名函数
  - 在函数中定义的内部函数可以引用该函数的变量!!!
  - 函数值不仅仅是一串代码，还记录了状态
    - Go 使用闭包(Closures)实现函数值,Go程序员也把函数值称为闭包

- 警告: 捕获迭代变量!
  - `函数值`中记录的是循环变量的`内存地址`，而不是循环变量某一时刻的值
```go
var rmdirs []func()
for _, d := range tempDirs() {
    dir := d // NOTE: necessary!!!!!!!!!!!!!!!!!!!!!!
    os.MkdirAll(dir, 0755) // creates parent directories too
    rmdirs = append(rmdirs, func() {
        os.RemoveAll(dir)
    })
}
// ...do some work…
for _, rmdir := range rmdirs {
    rmdir() // clean up
}

```

- defer
  - 只有包含该`defer`语句的函数执行完毕时,defer函数才会被执行
    - 释放资源的defer应该直接跟在请求资源的语句后
  - 多条defer执行的顺序: 栈

- panic
  - 适用于严重漏洞
  - 不够优雅,不要随便用,做好错误处理

- recover 捕获异常
```go
func Parse(input string) (s *Syntax, err error) {
    defer func() {
        if p := recover(); p != nil {
            err = fmt.Errorf("internal error: %v", p)
        }
    }()
    // ...parser...
}
```

# 方法
#### 方发声明
- 在函数声明时，在其名字之前放上一个变量，即是一个方法
- 对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名

#### 基于指针对象的方法
- 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换
- 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝

#### 通过嵌入结构体来扩展类型
