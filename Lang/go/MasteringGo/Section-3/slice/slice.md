# 切片
- Go的切片十分强大，可以毫不夸张地说切片完全能够取代数组。只有非常少的情况下，你才需要创建数组而非切片，最常见的场景就是你`非常确定`你所存储的元素数量
- 切片的底层是 `数组`
- 切片作为函数的形参时是传引用操作,传递的是地址
  - 在函数中对切片做的任何操作都会在函数结束后体现出来

# 基本操作
- Go 自动将空切片的元素初始化为对应元素的零值
  - 意思就是切片初始化时的值由切片类型决定
- 使用`append`追加元素到切片,此操作将触发切片自动扩容
- 使用 `[:]` 获取元素
- `s2 := integer[1:3]` 叫做 `re-slice`
  - 通过 re-slice 得到的切片与原切片指向同一片内存地址
> re-slicing操作的第二个问题是，尽管你可能是想通过使用re-slicing从原切片中得到较小的一个切片，但是原切片的底层数组仍然会跟随着re-slicing得到的小切片，这对于小切片来说并不是什么严重问题，但是在这种情况下就可能导致bug：你将大文件的内容读到切片中，但是你只是想使用其中一小部分
- 针对以上情况可以使用切片的`拷贝`
```go
func main() {
	source := []int{1, 2, 3, 4, 5}
	destination := make([]int, len(source))

	copy(destination, source)

	fmt.Println("源切片:", source)
	fmt.Println("目标切片:", destination)
}
```

# 切片的自动扩容
- 容量: `cap()`
- 长度: `len()`
- 容量不够就扩容为 `2倍`

# 字节切片
- `s := make([]byte, 5)`
- 在输入输出(网络,文件流等)用的非常多

# copy() 函数
- 复制切片
- 使用 `copy()` 时你应小心翼翼，因为内建函数 `copy(dst,src)` 会以 `len(dst)` 和 `len(src)` 中的最小值为复制长度

# 多维切片
- `s1 := make([][]int, 4)`