主要关注磁盘文件的I/O操作

# 4.1 概述
- 所有执行I/O操作的系统调用都是以文件描述符来指代打开的文件
- 用`<unistd.h>`定义的`POSIX`标准名称指代文件描述符更为可取

# 4.2 通用I/O
- `open() read() write() close()`可以对所有类型的文件执行I/O操作
- `ioctl()`为通用I/O模型之外的专有特性提供了访问接口

# 4.3 打开一个文件：open()
- 既能打开已存在，也能创建并打开新文件
- open()的flag参数：`P60`
- open()的错误：`P63`
- create()
    - 等价于`fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode)`

# 4.4 读取文件内容：read()
- 从文件描述符fd所指代的文件中读取数据
- 系统调用不会分配内存缓冲区信息给调用者，所以必须预先分配好大小合适的缓冲区并将缓冲区指针传递给系统调用
    - 有些库函数却会分配内存缓冲区用以返回信息给调用者
    - 缓冲区大小至少要比预计读取的最大字符串长度多出一字节

# 4.5 数据写入文件：write()
- 将数据写入一个已打开的文件夹
  
# 4.6 关闭文件：close()
- 关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用
- 当一个进程终止时，将自动关闭其已打开的所有文件描述符

# 4.7 改变文件偏移量：lseek()
- 文件偏移量：读写偏移量/指针
- 指执行下一个read()或write()操作的文件起始位置，会以相对于文件头部起始点的文件当前位置表示
- 文件第一个字节的偏移量为0

## 文件空洞
- 从文件结尾后到新写入数据间的空间
- 文件空洞是存在字节的，读取空洞将返回0(空字节)填充的缓冲区
- 文件空洞不会占用任何磁盘空间，直到在文件空洞中写入数据，文件系统才会为其分配磁盘块

# 4.8 通用I/O模型以外的操作：ioctl()
- 需注意可移植性

