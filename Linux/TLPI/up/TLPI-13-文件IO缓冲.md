# 13.1 文件I/O的内核缓冲：高速缓冲区
- read()和write()系统调用在操作磁盘文件时不会直接发起磁盘访问，而是在`用户空间缓冲区 和 内核缓冲区高速缓存`之间 **复制数据**
- 系统调用与磁盘调用并不同步
- 意在使`read()/write()`调用更加快速，不用等待缓慢的磁盘操作
- 缓冲区大小`BUF_SIZE`的设定很关键，对程序运行时间起关键影响：
    - 在大文件I/O，通过采用大块空间缓冲数据，以及执行更少的系统调用，可以极大的提供I/O性能

# 13.2 stdio库的缓冲
- C语言函数库的I/O函数：操作磁盘文件时，缓冲大块数据以减少系统调用
- 使用stdio库可以使编程者免于自行处理对数据的缓冲

## 设置一个stdio流的缓冲模式
- `setvbud()`可以控制stdio库使用缓冲的模式
- `setbuf()`构建于setvbuf()之上
- `setbufer()`类似于setbuf()

## 刷新stdio缓冲区
- 任意时刻，都可通过`fflush()`库函数强制将stdio输出流中的数据(通过`write()`)刷新到内核缓冲区中：此函数会 **刷新指定stream的输出缓冲区**
- 若打开一个流同时用于输入和输出：
    - 一个`输出`不能紧跟一个`输入`，必须在两者之间调用fflush()函数或是一个文件定位函数
    - 一个`输入`不能紧跟一个`输出`，必须在两者之间调用一个文件定位函数，除非输入操作遭遇文件结尾

# 13.3 控制文件I/O的内核缓冲
- 强制刷新内核缓冲区到输出文件是有可能的
- SUSv3对 **同步I/O完成** 定义为：
    - 已经成功完成到磁盘的数据传递
    - 被诊断为不成功
- SUSv3定义了两种不同类型的 **同步I/O成功**：
    1. `synchronized I/O data integrity completion`
    2. `Synchronized I/O file integrity completion`
    3. 2是1的**超集**

## 用于控制文件I/O内核缓冲的系统调用
- `fsync()`：将 **缓冲数据** 和 **打开文件描述符fd相关的所有元数据** 都刷新到磁盘上
- 强制使文件处于`Synchronized I/O file integrity completion`状态
- `fdarasync()`：类似fsync()，但强制使文件处于`Synchronized I/O data integrity completion`状态
- `sync()`：将包含更新文件信息的所有内核缓冲区(即数据块、指针块、元数据等)刷新到磁盘上

## 使所有写入同步：O_SYNC
- open()的标志
- 按照`2`模式执行写操作
- O_SYNC或者频繁调用fsync()类 **对性能影响极大**
- O_DSYNC:按照`1`模式执行写操作
- O_RSYNC:与其余两标志之一结合使用

# 13.4 I/O缓冲小结
![](https://s3.bmp.ovh/imgs/2022/05/18/923c05386fc0c78e.png)

# 13.5 就I/O模式向内核提出建议
- `posix_fadvise()`允许进程就自身访问文件数据时可能采取的模式通知内核
- 内核不一定理会这个请求

# 13.6 绕过缓冲区高速缓存：直接I/O
- `direct I/O` / `raw I/O`
- 可针对一个单独文件或块设备(例如一块硬盘)执行直接I/O：在open()时指定`O_DIRECT`标志

## 直接I/O的对齐限制
- 用于传递数据的缓冲区，其内存边界必须对齐为块大小的整数倍
- 数据传输的开始点(文件和设备的偏移量)，必须是块大小的整数倍
- 待传递数据的长度必须是块大小的整数倍

# 13.7 混合使用库函数和系统调用进行文件I/O
- `fileno()`与`fdopen()`
- fielno()：给定流返回对应文件描述符
- fdopen()：给定文件描述符返回对应流

- 一定要处理好缓冲问题
- 使用fflush()规避混乱