# 5.1 原子操作和竞争条件
- 竞争状态：操作共享资源的两个进程(或线程)，其结果取决于一个无法预期的顺序：获取CPU使用权有先后
- 原子性：规避竞争状态

# 5.2 文件控制操作：fcntl()
- 对一个打开的文件描述符执行一系列操作

# 5.3 打开文件的状态标志
- fcntl()的一个功能为获取或修改一个打开文件的访问模式或状态标志，若想获取这些设置，应将fcntl()的cmd参数设置为`G_GETFL`

# 5.4 文件描述符和打开文件之间的关系
- 多个文件描述符指向同一文件：既可能，也必要

- 内核维护的三个数据结构：
    - 进程级的文件描述符表
    - 系统级的文件打开表
    - 文件系统的i-node表
- 针对每个**进程**， 内核为其维护 **打开文件的描述符**表`(open file descriptor)`,该表的每一条目都记录了**单个文件描述符**的相关信息：
    - 控制文件描述符操作的一组标志(即`close-on-exec`)
    - 对 **打开文件句柄** 的引用
- 内核为 **所有打开的文件** 维护有一个 **系统级的描述表格/ (打开文件表)**`(open file description table) / (open file table)`，并将表中各条目称为 **打开文件句柄**`(open file handle)`
- 一个 文件句柄 存储了与一个 打开文件 相关的所有信息：
    - 当前文件偏移量
    - 打开文件时使用的状态标志
    - 文件访问模式
    - 与信号驱动I/O相关的设置
    - 对该文件i-node对象的引用
- 每个文件系统都会为驻留其上的所有文件建立一个`i-node表`
- 文件的`i-node信息`：
    - 文件类型和访问权限
    - 一个指针，指向该文件所持有的锁的列表
    - 文件的各种属性
![](https://s3.bmp.ovh/imgs/2022/05/17/acf2e9a1e6b337c7.png)

# 5.5 复制文件描述符
- dup()
- dup2()
- dup3()

# 5.6 在文件特定偏移量处的I/O：pread()和pwrite()
- 只会在参数指定位置进行文件I/O操作
- 不会改变文件的当前偏移量
- 调用时需确保fd所指代的文件必须是可定位的(允许对文件描述符执行lseek()操作)

- 适用于多线程操作

# 5.7 分散输入和集中输出：readv() & writev()
- Scatter-Gather I/O
  
## 分散输入
- readv()从文件描述符 fd 所指代的文件中读取一片连续的字节，然后将其散置（“分散放置”）于 iov 指定的缓冲区中
- readv()具有原子性

## 集中输出
- writev()将 iov 所指定的所有缓冲区中的数据拼接（“集中”）起来，然后以连续的字节序列写入文件描述符 fd 指代的文件中
- 具有原子性

## preadv() & pwritev()
- 合二为一

# 5.8 截断文件：truncate() & ftruncate()系统调用
- 将文件大小设置为参数值
- 参数小于文件大小：丢弃超出部分
- 参数大于文件大小：添加一系列空字节或文件空洞

- `truncate()`无需open()获取文件描述符就可修改文件内容，在系统调用中是独树一帜

# 5.9 非阻塞I/O
- 打开文件时指定`O_NONBLOCK`标志

# 5.10 大文件I/O
- 过渡性LFS API
- `_FILE_OFFSET_BITS`宏

# 5.11 /dev/fd 目录
- 内核提供的特殊虚拟目录
- 实际为符号链接，链接到Linux专有的`/prov/self/fd`目录

# 5.12 创建临时文件
- 仅供程序运行期间使用，程序终止后立刻删除
- `mkstemp()` & `tmpfile()`
- `unlink()`&&`mkstemp()`：Name disappears immediately, but the file is removed only after close()