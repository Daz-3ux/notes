# 58.1 互联网
- 互联网`internet`:将不同的计算机网络连接起来并允许位于网络中的主机相互之间进行通信
- 互联网`Internet`:全球数亿计算机连接起来的TCP/IP网络

- 路由器:
    - 更通用的叫法为"**多宿主机**"
    - 将包从一个子网转发到另一个子网的一台多宿主机
    - 一个多宿主机的各个接口上的网络地址是不同的

# 58.2 联网协议和层
- 联网协议是定义在一个网络上传输信息的一组规则
- 联网协议通常被组织成一系列的层,其中每一层都构建于下层之上并提供特性以供上层使用
- TCP/IP 协议套件是一个分层联网协议:
    - 包括因特网协议（ IP）和位于其上层的各个协议层
    - 每一个协议层都对上层隐藏下层的操作和复杂性

## 封装
- 封装是分层联网协议中的一个重要的原则
- 其关键概念为:底层会将从高层到底层传递的信息当作不透明的数据来处理:低层不会尝试对高层发送过来的信息进行解释，而只会将这些信息放到低层所使用的包中并在将这个包向下传递到低层之前 **添加自身这一层的头信息**

![](https://s3.bmp.ovh/imgs/2022/05/23/a5464e3432df8b5f.png)

![](https://s3.bmp.ovh/imgs/2022/05/23/812195966abc4687.png)

![](https://s3.bmp.ovh/imgs/2022/05/23/0ec75013c8546bd2.png)

# 58.3 数据链路层
- 由设备驱动 / 底层设备媒介 / 硬件接口 组成
- 数据链路层关注的是在一个网络的 **物理链接** 上传输数据
- 数据链路层需要将网络层传递过来的数据报封装进被称为`帧`的一个一个单元
- 从应用程序编程的角度来讲通常可以忽略数据链路层，因为所有的通信细节都是由驱动和硬件来处理的
- 需要关注的就是数据链路层的`MTU`:该层能传输的帧大小的上限, 不同的数据链路层的MTU是不同的

# 58.4 网络层:IP
- 关注的是如何将包(数据)从 **源主机** 发送到 **目标主机**
- 执行以下任务:
    - 将数据分解成`足够小的片段`以便数据链路层进行传输（如有必要的话）
    - 在因特网上路由数据
    - 为传输层提供服务

## IP传输数据报
- IP以数据包的形式传输数据

## IP是无连接和不可靠的
- 无连接:并没有在相互连接的两个主机之间提供一个虚拟电路
- 不可靠:不保证数据到达顺序,不保证数据是否重复,甚至不保证数据是否到达
- 不提供错误恢复:头结点错误的包会被静默丢弃

- 其可靠性通过使用`可靠的传输层协议(TCP)` 或 `应用程序本身`来`保证`

## IP可能对数据报进行分段
- 当一个 IP 数据报的大小大于 MTU 时， IP 会将数据报分段（分解）成一个个大小适合在网络上传输的单元
- 这些分段在达到最终目的地之后会被重组成原始的数据报

# 58.5 IP地址
- 由两部分组成:
    - 网络ID:指定了主机所属网络
    - 主机ID:标识出位于该网络中的主机

## IPv4地址
- 32位

![](https://s3.bmp.ovh/imgs/2022/05/23/1cc9455b8c744e3d.png)

```
204.152.189.0/24
/24表示分配的地址的网络ID由最左边24位(三字节)组成,剩余八位用于指定主机ID
```
- `主机地址都是0`:用来标识网络本身(204.152.189.`0`)
- `主机地址的位都是1`:子网广播地址(204.152.189.`255`)
- `127.0.0.1`:本地回环地址
    - 发送到这个地址的数据报实际上不会到达网络,其会自动回环变为主机的输入
    - 用来测试统一主机上的客户端和服务器程序
    - `INADDR_LOOPBACK`

- IPv4通配地址:`INADDR_ANY`
    - 对于将 Internet domain socket 绑定到多宿主机上的应用程序比较有用

- IPv4子网划分
![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206141655854.png)


## IPv6地址
- 128位

# 58.6 传输层
- 在TCP/IP套件中广泛使用的两个传输层协议
    - 用户数据报协议(`UDP`):数据报socket所使用
    - 传输控制协议(`TCP`):流socket所使用

## 58.6.1 端口号
- 传输层需要一种方法来区分一个主机上的应用程序:在TCP和UDP中,使用一个 **16位的端口号实现**
- 特权端口号:有的端口号已经名花有主,不能再使用
- 临时端口:在 Linux 上，临时端口号范围是由包含在文件`/proc/sys/net/ipv4/ip_local_port_range` 中的两个数字来定义的(可修改)
```
$ cat /proc/sys/net/ipv4/ip_local_port_range
32768 60999
```

## 58.6.2 用户数据报协议(UDP)
- UDP 仅仅在 IP 之上添加了两个特性： 
    - 端口号
    - 一个进行检测传输数据错误的数据校验和
    - UDP 和 TCP 使用的校验和的长度只有 16 位并且只是简单的“总结性”校验和，因此无法检测出特定的错误
- 无连接 / 不可靠
- 如果剔除不可靠这个特点的话，在有些时候可能倾向于使用 UDP 而不是 TCP

### 选择一个UDP数据报大小以避免IP分段
- TCP 提供了避免 IP 分段的机制, 但 UDP 并没有提供相应的机制
使用 UDP 时如果传输的数据报的大小超过了本地数据链接的 MTU，那么很容易就会导致 IP 分段

## 58.6.3 传输控制协议(TCP)
TCP在两个端点之间提供 `可靠的` `面向连接的` `双向字节流通信信道`

![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202205232052812.png)

### 连接建立
- 建立连接期间:发送者和接受者需要`交换选项来协商通信参数`

### 数据打包成段
- 每一个段都包含一个校验和，从而能够检测出`端到端的传输错误`
- 每一个段使用单个 IP 数据报来传输

### 确认 重启 超时
- 当一个 TCP 段无错地达到目的地时，接收 TCP 会向发送者发送一个确认
- 发送者在发送一个段时会开启一个定时器:如果在定时器超时之前没有收到确认，那么就会重传这个段

### 排序
- 在每一个段加上一个序号的作用:
    - 这个序号使得 TCP 分段能够以正确的顺序在目的地进行组装， 然后以字节流的形式传递给应用层
    - 接收者返回给发送者的确认消息可以使用序号来标识出收到了哪个 TCP 分段
    - 接收者可以使用序号来移除重复的分段
- 流的初始序号(`ISN`)不是从0开始,而是以算法生成

### 流量控制
- 接受TCP为进入的数据维护一个缓冲区实现流量控制:每个 TCP 在连接建立阶段会通告其缓冲区的大小
-  TCP 流量控制算法采用了`滑动窗口`算法

### 拥塞控制：慢启动和拥塞避免算法
- 防止快速的发送者压垮整个网络
- TCP 的拥塞控制策略组合采用了两种算法：慢启动和拥塞避免
    - 慢启动:慢启动算法会使发送 TCP 在一开始的时候以低速传输分段，但同时允许它以指数级的速度提高其速率，只要这些分段都得到接收 TCP 的确认
    - 拥塞避免:为速率指数级别的的增长安排了一个管理实体
- 允许数据传输快速地到达一个`平衡状态`:发送者传输包的速率与它从接收者处接收确认的速率一致

# tips:
![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206101025965.png)
