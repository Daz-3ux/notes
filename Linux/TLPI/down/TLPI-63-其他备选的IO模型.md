- 除常规I/O模型外,还有三种可选的I/O模型
    - I/O多路复用(`select()` 和 `poll()`)
    - 信号驱动I/O
    - Linux专有的epoll编程接口

# 63.1 整体概览
- 在每次I/O系统调用都会阻塞直到完成数据传输的前提下:
    - 当从一个管道中读取数据时,如果恰好没有数据,那么通常read()会阻塞
    - 如果管道中没有足够的空间保存待写入的数据时,write()会阻塞

- 需要处理的需求:
    - 以非阻塞的方式检查文件描述符上是否可以进行I/O操作
    - 同时检查多个文件描述符,看他们之一是否可以执行I/O操作
- 可以部分满足这些需求的技术:`非阻塞式I/O` 和 `多进程/多线程`

- 非阻塞式I/O可以让我们 **周期地检查(轮询)** 某个文件描述符上是否可以执行I/O操作,但是 **在一个紧凑的循环中做轮询就是在浪费CPU**

- 轮询: `poll`

- `多线程`特别有用的一个地方是如果应用程序需要调用一个会执行阻塞式 I/O 操作的第三方库， 那么可以通过在分离的线程中调用这个库从而避免应用被阻塞

- 由于 非阻塞式I/O 和 多线程/多进程 都存在局限性,所以引出以下方法:
    - `I/O多路复用`:允许进程同时检查多个文件描述符以找出它们中的任何一个是否可执行I/O 操作. 系统调用 select()和 poll()用来执行 I/O 多路复用
    - `信号驱动I/O`:当有输入或者数据可以写到指定的文件描述符上时， 内核向请求数据的进程发送一个信号。进程可以处理其他的任务，当 I/O 操作可执行时通过接收信号来获得通知。同时检查大量的文件描述符时，信号驱动 I/O 相比 select()和 poll()有显著的性能提升
    - `epoll API`:epoll API 允许进程同时检查多个文件描述符，看其中任意一个是否能执行 I/O 操作。同信号驱动 I/O 一样，当同时检查大量文件描述符时，epoll 能提供更好的性能(Linux专有特性)
- 都是为了实现同一个目标:同时检查多个文件描述符，看它们是否准备好了执行 I/O 操作(I/O系统调用是否可以非阻塞的执行)

- 选择哪种
    - 系统调用 select()和 poll()在 UNIX 系统中已经存在了很长的时间:**可移植性高** / **处理大量文件描述符时 性能延展性不佳**
    - epoll API:**处理大量文件描述时 性能高** / **为Linux专属**
    - 信号驱动I/O: ***处理大量文件描述时 性能高**,epoll相较于其的优点:
1. 避免了处理信号的复杂性
2. 可以指定想要检查的事件类型(读就绪或者写就绪)
3. 可以选择以水平触发或边缘触发的形式来通知进程

## 63.1.1 水平触发和边缘触发
- 通知文件描述符准备完毕的通知模式
- `水平触发`:如果文件描述符上**可以非阻塞地执行 I/O 系统调用**，此时认为它已经就绪
- `边缘触发`:如果文件描述符**自上次状态检查以来有了新的 I/O 活动（比如新的输入）**，此时触发边缘通知

![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206022101042.png)

- 水平触发模式允许我们`在任意时刻重复检查 I/O 状态`，所以没有必要每次当文件描述符就绪后需要`尽可能多`地执行 I/O（也就是尽可能多地读取字节，亦或是根本不去执行任何 I/O）
- 边缘触发时，只有当 I/O 事件发生时我们才会收到通知,所以
    - 需要`尽可能多地执行I/O`
    - 每个被检查的文件描述符通常都应该置为非阻塞模式

## 63.1.2 在备选的I/O模型中采用非阻塞I/O
- 非阻塞 I/O 通常和提供有边缘触发通知机制的 I/O 模型一起使用


# 63.2 I/O 多路复用
- I/O多路复用允许我们同时检查多个文件描述符,看其中任意一个是否可执行I/O操作

## 63.2.1 select()系统调用
- **系统调用 select()会一直阻塞，直到一个或多个文件描述符集合成为就绪态**
- 文件描述符集合有一个最大容量限制，由常量 FD_SETSIZE 来决定(Linux中其值为1024)
- 如果要在循环中重复调用 select()，我们必须保证每次都要重新初始化它们

## 63.2.2 poll()系统调用
- 系统调用 poll()执行的任务同 select()很相似
- 主要的区别在于我们要如何指定待检查的文件描述符

## 63.2.3 文件描述符何时就绪
- 正确使用 select()和 poll()需要理解在什么情况下文件描述符会表示为就绪态
- 如果对 I/O 函数的调用不会阻塞，而不论该函数是否能够实际传输数据，此时文件描述符（未指定`O_NONBLOCK`标志）被认为是就绪的

- `普通文件`:代表普通文件的文件描述符总是被 select()标记为可读和可写。对于 poll()来说，则会在revents 字段中返回 POLLIN 和 POLLOUT 标志
    - read()总是会立刻返回数据、文件结尾符或者错误
    - write()总是会立刻传输数据或者因出现某些错误而失败

- 终端和伪终端

- 管道和FIFO

- 套接字
    - 对于 poll()这一列， 我们假设 events字段已经指定了（ POLLIN | POLLOUT | POLLPRI）标志位
    - 对于 select()这一列，我们假设需要检查文件描述符的输入、输出以及异常情况是否发生
    - 常见情况表:
![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206022204833.png)

## 63.2.4 比较 select()和 poll()
- 实现细节
    - 在 Linux 内核层面， select()和 poll()都使用了相同的内核 poll 例程集合
    - 如果被检查的文件描述符当中有一个关闭了， poll()会在 revents 字段中返回 `POLLNVAL`，而 select()会`返回−1` 且将错误码设为 EBADF

- API之间的区别
    - `select()`所使用的数据类型 fd_set 对于被检查的文件描述符数量有一个上限限制,`poll()`对于被检查的文件描述符数量本质上是 **没有限制的**
    - 因为fd_set也是保存调用结果的地方,如果要在循环中重复调用select()的话， 我们必须每次都要重新初始化 fd_set,而 poll()通过独立的两个字段 events（针对输入）和 revents（针对输出）来处理，从而避免每次都要重新初始化参数
    - 如果其中一个被检查的文件描述符关闭了，通过在对应的 revents 字段中设定POLLNVAL 标记， poll()会准确告诉我们是哪一个文件描述符关闭了。与之相反， select()只会返回−1，并设错误码为 EBADF

- 可移植性
    - 如今这两个接口都在 SUSv3 中标准化了

- 性能
    - 当如满足如下两条中任意一条时， poll()和 select()将具有性能表现相似:
1. 待检查的文件描述符范围较小（即，最大的文件描述符号较低）
2. 有大量的文件描述符待检查，但是它们分布得很密集
    - 当被检查的文件描述符集合很稀疏的话:poll()的性能表现将**优于** select()[在 2.6 版内核中通过一些优化手段，这个性能差异已经被极大地缩小了]

## 63.2.5 select()和 poll()存在的问题
- 随着待检查的文件描述符数量的增加， select()和 poll()所占用的CPU 时间也会随之增加
- select()和 poll()糟糕的性能延展性源自这些 API 的局限性：通常，程序重复调用这些系统调用所检查的文件描述符集合都是相同的，可是内核并不会在每次调用成功后就记录下它们

# 63.3 信号驱动 I/O
- 在信号驱动 I/O 中，当文件描述符上可执行 I/O 操作时，进程请求内核为自己发送一个信号。之后进程就可以执行任何其他的任务直到 I/O 就绪为止，此时内核会发送信号给进程

![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206022220790.png)

## 63.3.1 何时发送“I/O 就绪”信号
- 终端和伪终端

- 管道和FIFO

- 套接字
    - 信号驱动 I/O 可适用于 UNIX 和 Internet 域下的 **数据报套接字**
    - 信号会在下列情况中产生:
1. 一个输入数据报到达套接字（即使已经有未读取的数据报正等待读取）
2. 套接字上发生了异步错误

    - 信号驱动 I/O 可适用于 UNIX 和 Internet 域下的流式套接字
    - 信号会在下列情况产生:
1. 监听套接字上接收到了新的连接
2. TCP connect()请求完成，也就是 TCP 连接的主动端进入 ESTABLISHED 状态
3. 套接字上接收到了新的输入（即使已经有未读取的输入存在）
4. 套接字对端使用 shutdown()关闭了写连接（半关闭），或者通过 close()完全关闭
5. 套接字上输出就绪（例如套接字发送缓冲区中有了空间）
6. 套接字上发生了异步错误
    - inotify文件描述符:
        - 当inotify 文件描述符成为可读状态时会产生一个信号—也就是由 inotify 文件描述符监视的其中一个文件上有事件发生时

## 63.3.2 优化信号驱动 I/O 的使用
- 要想全部利用信号驱动 I/O 的优点，我们必须执行下面两个步骤:
    - 通过专属于 Linux 的 fcntl() F_SETSIG 操作来指定一个实时信号，当文件描述符上的I/O 就绪时，这个实时信号应该取代 SIGIO 被发送
    -使用 sigaction()安装信号处理例程时，为前一步中使用的实时信号指定 SA_ SIGINFO标记

# 63.4 epoll 编程接口
- Linux系统 **专有**!!, 在2.6版新增
- 优点:
    - 当检查大量的文件描述符时， epoll 的性能延展性比 select()和 poll()高
    - epoll API 既支持水平触发也支持边缘触发
    - (相较于信号驱动I/O)
    - 可以避免复杂的信号处理流程
    - 灵活性高，可以指定我们希望检查的事件类(检查套接字文件描述符的读就绪、写就绪或者两者同时指定)

- epoll API 的核心数据结构被叫做 **epoll实例**, 其和一个打开的文件描述符相关联
- 此文件描述符是内核数据结构的句柄,实现了两个目的:
    - 记录了在进程中声明过的感兴趣的文件描述符列表--`interest list(兴趣列表)`
    - 维护了处于I/O就绪态的文件描述符列表--`ready list(就绪列表)`
    - ready list 是 interset list 的子集

- epoll API 由以下三个系统调用组成:
    - `epoll_create()`:创建一个epoll实例
    - `epoll_ctl()`:操作同epoll实例相关联的兴趣列表
    - `epoll_wait`:返回与epoll实例相关联的就绪列表中的成员

## 63.4.1 创建 epoll 实例： `epoll_create()`
- 创建一个新的epoll实例,其对应的`兴趣列表为空`
```c
#include <sys/epoll.h>

int epoll_create(int size);
//return file descriptor on success, -1 on error
```
- 参数size指定我们想要通过epoll实例来检查的文件描述符的个数(已废除不用)
- 返回代表新创建的 epoll 实例的文件描述符(通过close()关闭)
- 当所有与 epoll 实例相关的文件描述符都被关闭时，实例被销毁，相关的资源都返还给系统
- ![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206041204363.png)

## 63.4.2 修改 epoll 的兴趣列表： epoll_ctl()
```c
#include <sys/epoll.h>

int epoll_ctl(int epfd, int op, struct epoll_event *ev);
//return 0 on success, -1 on error
```
- fd指定了要修改兴趣列表中哪一个文件描述符的设定(`不能作为普通文件或目录的文件描述符`)
- op指定要执行的操作
- ev是指向结构体`epoll_event`的指针
```c
struct epoll_event{
    uint32_t events;
    epoll_data_t data;
};

typedef union epoll_data{
    void    *ptr;
    int      fd;
    uint32_t u32;
    uint64_t u64;
}epoll_data_t;
```
- ev做如下设置:
    - `events`: **位掩码** 指定了我们为待检查的文件描述符fd上所感兴趣的事件集合
    - `data`: **联合体** 指定传回给调用程序的信息

```c
in epfd;
struct epoll_event ev;

epfd = epoll_create(5);
if(epfd == -1){
    perror(create);
}

ev.data.fd = fd;
ev.events = EPOLLIN;
if( epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1){
    perror(ctl);
}
```

- 内核提供了一个接口用来定义每个用户可以注册到 epoll 实例上的文件描述符总数:`max_user_watches` 是专属于 Linux 系统的/proc/sys/fd/epoll 目录下的一个文件(In My Mint:`3311964`)

## 63.4.3 事件等待： epoll_wait()
- 返回 epoll 实例中处于就绪态的文件描述符信息
- `单个` epoll_wait()调用能返回`多个`就绪态文件描述符的信息
```c
#include <sys/epoll.h>

int epoll_wait(int epfd, struct epoll_event * evlist, int maxevents, int timeout);
//return number pf ready file descriptors, 0 on timeout, -1 on error
```
- 参数`evlist`所指向的结构体数组中返回的是有关就绪态文件描述符的信息
- 数组evlist的空间由调用者负责申请,包含的元素个数在maxevents指定
- 要么将`ev.data.fd`设为文件描述符号，要么将`ev.data.ptr`设为指向包含文件描述符号的结构体

- `timeout`确定epoll_wait()的阻塞行为
    - timeout == -1 : 一直阻塞,直到兴趣列表中的文件描述符上有事件产生,或者直到捕获到一个信号
    - 如果 timeout 等于 0，执行一次非阻塞式的检查，看兴趣列表中的文件描述符上产生了哪个事件
    - 如果 timeout 大于 0，调用将阻塞至多 timeout 毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止

- 调用成功返回evlist中的元素个数

## 63.4.4 深入探究 epoll 的语义
- 一旦所有指向打开的`文件描述`的`文件描述符`都被关闭后，这个打开的`文件描述`将从 epoll 的兴趣列表中移除
- 文件描述：`抽屉`——一个完整的数据结构
- 文件描述符：`把手`——“打开”抽屉的一个整数

## 63.4.5 epoll 同 I/O 多路复用的性能对比
- 常见的能够高效使用 epoll API 的应用场景就是**需要同时处理许多客户端**的服务器：**需要监视大量的文件描述符，但大部分处于空闲状态，只有少数文件描述符处于就绪态**

## 63.4.6 边缘触发通知
- 边缘触发通知通常和非阻塞的文件描述符结合使用
- 当采用边缘触发通知时避免出现文件描述符饥饿现象


# 63.5 在信号和文件描述符上等待
- 有时候，进程既要在一组文件描述符上等待 I/O 就绪，也要等待待发送的信号
- Linux 提供了一种新的技术**可同时等待信号和文件描述符状态**:`signalfd`

## 63.5.1 pselect()系统调用
- 有一个附加的参数—`sigmask`:指定了当调用被阻塞时哪些信号可以不被过滤掉

- pselect()中的 timeout 参数是一个 timespec 结构体，允许将超时时间精度指定为纳秒级（ select()为毫秒级）
- pselect()在返回时不会修改 timeout 参数

- `epoll_pwait`是epoll_wait的拓展

## 63.5.2 self-pipe 技巧
- 由于 pselect()并没有被广泛实现，`可移植`的应用程序必须采用其他手段来避免当等待信号并同时调用 select()时出现的竞态条件
- 即信号处理例程写一个字节数据到管道中，代表管道读端的文件描述符包含在被监视的文件描述符集合中