- 除常规I/O模型外,还有三种可选的I/O模型
    - I/O多路复用(`select()` 和 `poll()`)
    - 信号驱动I/O
    - Linux专有的epoll编程接口

# 63.1 整体概览
- 需要处理的需求:
    - 以非阻塞的方式检查文件描述符上是否可以进行I/O操作
    - 同时检查多个文件描述符,看他们之一是否可以执行I/O操作
- 可以部分满足这些需求的技术:`非阻塞式I/O` 和 `多进程/多线程`

- 非阻塞式I/O可以让我们 **周期地检查(轮询)** 某个文件描述符上是否可以执行I/O操作,但是 **在一个紧凑的循环中做轮询就是在浪费CPU**

- 轮询: `poll`

- `多线程`特别有用的一个地方是如果应用程序需要调用一个会执行阻塞式 I/O 操作的第三方库， 那么可以通过在分离的线程中调用这个库从而避免应用被阻塞

- 由于 非阻塞式I/O 和 多线程/多进程 都存在局限性,所以引出以下方法:
    - `I/O多路复用`:允许进程同时检查多个文件描述符以找出它们中的任何一个是否可执行I/O 操作. 系统调用 select()和 poll()用来执行 I/O 多路复用
    - `信号驱动I/O`:当有输入或者数据可以写到指定的文件描述符上时， 内核向请求数据的进程发送一个信号。进程可以处理其他的任务，当 I/O 操作可执行时通过接收信号来获得通知。同时检查大量的文件描述符时，信号驱动 I/O 相比 select()和 poll()有显著的性能提升
    - `epoll API`:epoll API 允许进程同时检查多个文件描述符，看其中任意一个是否能执行 I/O 操作。同信号驱动 I/O 一样，当同时检查大量文件描述符时，epoll 能提供更好的性能(Linux专有特性)
- 都是为了实现同一个目标:同时检查多个文件描述符，看它们是否准备好了执行 I/O 操作(I/O系统调用是否可以非阻塞的执行)

- 选择哪种
    - 系统调用 select()和 poll()在 UNIX 系统中已经存在了很长的时间:**可移植性高** / **处理大量文件描述符时 性能延展性不佳**
    - epoll API:**处理大量文件描述时 性能高** / **为Linux专属**
    - 信号驱动I/O: ***处理大量文件描述时 性能高**,epoll相较于其的优点:
1. 避免了处理信号的复杂性
2. 可以指定想要检查的事件类型(读就绪或者写就绪)
3. 可以选择以水平触发或边缘触发的形式来通知进程

## 63.1.1 水平触发和边缘触发
- 通知文件描述符准备完毕的通知模式
- `水平触发`:如果文件描述符上**可以非阻塞地执行 I/O 系统调用**，此时认为它已经就绪
- `边缘触发`:如果文件描述符**自上次状态检查以来有了新的 I/O 活动（比如新的输入）**，此时触发边缘通知

![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206022101042.png)

- 水平触发模式允许我们`在任意时刻重复检查 I/O 状态`，所以没有必要每次当文件描述符就绪后需要`尽可能多`地执行 I/O（也就是尽可能多地读取字节，亦或是根本不去执行任何 I/O）
- 边缘触发时，只有当 I/O 事件发生时我们才会收到通知,所以
    - 需要`尽可能多地执行I/O`
    - 每个被检查的文件描述符通常都应该置为非阻塞模式

## 63.1.2 在备选的I/O模型中采用非阻塞I/O
- 非阻塞 I/O 通常和提供有边缘触发通知机制的 I/O 模型一起使用


# 63.2 I/O 多路复用

## 63.2.1 select()系统调用
- 系统调用 select()会一直阻塞，直到一个或多个文件描述符集合成为就绪态
- 文件描述符集合有一个最大容量限制，由常量 FD_SETSIZE 来决定(Linux中其值为1024)
- 如果要在循环中重复调用 select()，我们必须保证每次都要重新初始化它们

## 63.2.2 poll()系统调用
- 系统调用 poll()执行的任务同 select()很相似
- 主要的区别在于我们要如何指定待检查的文件描述符

## 63.2.3 文件描述符何时就绪
- 正确使用 select()和 poll()需要理解在什么情况下文件描述符会表示为就绪态
- 如果对 I/O 函数的调用不会阻塞，而不论该函数是否能够实际传输数据，此时文件描述符（未指定`O_NONBLOCK`标志）被认为是就绪的

- `普通文件`:代表普通文件的文件描述符总是被 select()标记为可读和可写。对于 poll()来说，则会在revents 字段中返回 POLLIN 和 POLLOUT 标志
    - read()总是会立刻返回数据、文件结尾符或者错误
    - write()总是会立刻传输数据或者因出现某些错误而失败

- 终端和伪终端

- 管道和FIFO

- 套接字
    - 对于 poll()这一列， 我们假设 events字段已经指定了（ POLLIN | POLLOUT | POLLPRI）标志位
    - 对于 select()这一列，我们假设需要检查文件描述符的输入、输出以及异常情况是否发生
    - 常见情况表:
![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206022204833.png)

## 63.2.4 比较 select()和 poll()
- 实现细节
    - 在 Linux 内核层面， select()和 poll()都使用了相同的内核 poll 例程集合
    - 如果被检查的文件描述符当中有一个关闭了， poll()会在 revents 字段中返回 `POLLNVAL`，而 select()会`返回−1` 且将错误码设为 EBADF

- API之间的区别
    - `select()`所使用的数据类型 fd_set 对于被检查的文件描述符数量有一个上限限制,`poll()`对于被检查的文件描述符数量本质上是 **没有限制的**
    - 因为fd_set也是保存调用结果的地方,如果要在循环中重复调用select()的话， 我们必须每次都要重新初始化 fd_set,而 poll()通过独立的两个字段 events（针对输入）和 revents（针对输出）来处理，从而避免每次都要重新初始化参数
    - 如果其中一个被检查的文件描述符关闭了，通过在对应的 revents 字段中设定POLLNVAL 标记， poll()会准确告诉我们是哪一个文件描述符关闭了。与之相反， select()只会返回−1，并设错误码为 EBADF

- 可移植性
    - 如今这两个接口都在 SUSv3 中标准化了

- 性能
    - 当如满足如下两条中任意一条时， poll()和 select()将具有性能表现相似:
1. 待检查的文件描述符范围较小（即，最大的文件描述符号较低）
2. 有大量的文件描述符待检查，但是它们分布得很密集
    - 当被检查的文件描述符集合很稀疏的话:poll()的性能表现将**优于** select()[在 2.6 版内核中通过一些优化手段，这个性能差异已经被极大地缩小了]

## 63.2.5 select()和 poll()存在的问题
- 随着待检查的文件描述符数量的增加， select()和 poll()所占用的CPU 时间也会随之增加
- select()和 poll()糟糕的性能延展性源自这些 API 的局限性：通常，程序重复调用这些系统调用所检查的文件描述符集合都是相同的，可是内核并不会在每次调用成功后就记录下它们

# 63.3 信号驱动 I/O
- 在信号驱动 I/O 中，当文件描述符上可执行 I/O 操作时，进程请求内核为自己发送一个信号。之后进程就可以执行任何其他的任务直到 I/O 就绪为止，此时内核会发送信号给进程

![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206022220790.png)

## 63.3.1 何时发送“I/O 就绪”信号
- 终端和伪终端

- 管道和FIFO

- 套接字
    - 信号驱动 I/O 可适用于 UNIX 和 Internet 域下的 **数据报套接字**
    - 信号会在下列情况中产生:
1. 一个输入数据报到达套接字（即使已经有未读取的数据报正等待读取）
2. 套接字上发生了异步错误

    - 信号驱动 I/O 可适用于 UNIX 和 Internet 域下的流式套接字
    - 信号会在下列情况产生:
1. 监听套接字上接收到了新的连接
2. TCP connect()请求完成，也就是 TCP 连接的主动端进入 ESTABLISHED 状态
3. 套接字上接收到了新的输入（即使已经有未读取的输入存在）
4. 套接字对端使用 shutdown()关闭了写连接（半关闭），或者通过 close()完全关闭
5. 套接字上输出就绪（例如套接字发送缓冲区中有了空间）
6. 套接字上发生了异步错误
    - inotify文件描述符:
        - 当inotify 文件描述符成为可读状态时会产生一个信号—也就是由 inotify 文件描述符监视的其中一个文件上有事件发生时

## 63.3.2 优化信号驱动 I/O 的使用
- 要想全部利用信号驱动 I/O 的优点，我们必须执行下面两个步骤:
    - 通过专属于 Linux 的 fcntl() F_SETSIG 操作来指定一个实时信号，当文件描述符上的I/O 就绪时，这个实时信号应该取代 SIGIO 被发送
    -使用 sigaction()安装信号处理例程时，为前一步中使用的实时信号指定 SA_ SIGINFO标记

# 63.4 epoll 编程接口