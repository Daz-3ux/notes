# 9-1 intro
- 初始的内核级进程通常是自己的父进程
- 进程间的会话
- 登录shell及其与进程的关系
- UNIX系统信号机制

# 9-2 终端登录

## BSD 终端登录
- getty
- login

## Mac OS X 终端登录
- 部分地基于FreeBSD，登录进程的工作步骤基本与BSD相同

## Linux 终端登录
- 非常类似于BSD

## Solaris 终端登录
支持两种形式：
1. getty形式
2. ttymon登录

# 9-3 网络登录
- 网络登录下终端与计算机之间的连接不再是点对点的
- 伪终端：使一个软件既能处理终端登录，又能处理网络登录

## BSD 网络登录
- 由`inetd`进程等待大多数网络连接
- 守护进程为inetd

## Mac OS X 网络登录
- 基本相同于BSD

## Linux 网络登录
- 基本相同于BSD
- 守护进程为`xinetd`：提供的控制更加精细

## Solaris 网络登录
- 基本相同于BSD

# 9-4 进程组
- 每个进程除了有**进程ID**之外，还属于一个进程组
- 进程组是**一个或多个进程**的集合
- 进程组ID是唯一的

## 返回调用进程的进程组ID的函数
```c
#include <unistd.h>

pid_t getpgrp(void);
//返回调用进程的进程组ID

pid_t getpgid(pid_t pid);
//成功返回进程组ID，失败返回-1
```
若上述函数2的pid值为0，则其返回调用进程的进程组ID

## 组长进程
- 每个进程组都有一个组长进程，组长进程的ID等于其进程组ID
- 组长进程可以创建一个进程组，创建组中进程，然后终止
- 只要组中有进程存在进程组就存在，不在乎组长是否已终结

## tips
- 进程组的最后一个进程可以终止，也可以转移到另一个进程组
- 加入一个现有进程组或创建一个新进程组函数：
```c
#include <unistd.h>

int setpgit(pid_t pid, pid_t pgid);
//成功返回0，失败返回-1
```
- 将pid进程的进程组ID设置为pgid
- pid == pgid：pid进程变进程组组长
- pid为0：使用调用进程的进程ID
- pgid为0：由pid指定的进程ID用作进程组ID
- 一个进程只能为它或它的子进程设置进程组ID，子进程调用exec后就不能再改变其的进程组ID

- fork之后父子进程均调用此函数，虽然冗余，但可以避免竞争关系

# 9-5 会话
- session：一个或多个进程组的集合
- 建立新会话函数：
```c
#include <unistd.h>

pid_t setsid(void);
//成功返回进程组ID，失败返回-1
```
- 若调用函数进程不是一个进程组的组长：
1. 该进程变为会话的**会话首进程**(session leader)，该进程成为新会话中的唯一进程
2. 该进程成为一个新进程组的组长进程
3. 该进程没有控制终端

- 若调用函数进程是一个进程组的组长：
1. 函数出错
2. 为避免此情况：父进程fork后终止父进程，由子进程进行调用

## 会话ID
- 会话首进程是**具有唯一进程ID**的**单个进程**，所以可以将会话首进程的进程ID视为会话ID
```c
#include <unistd.h>

pid_t getsid(pid_t pid);
//成功返回会话首进程的进程组ID，失败返回-1
```
- pid是0：返回调用进程的会话首进程的进程组ID
- pid不属于调用者所在的会话：出于安全，不返回ID

# 控制终端
- 一个会话可以有一个控制终端(controlling terminal)
    - 终端登录：为终端设备
    - 网络登录：为伪终端设备

- 控制进程(controlling process)：建立与控制终端连接的会话首进程
- 一个会话中的进程组可被分为**一个**`前台进程组(foreground process group)`和**一个或多个**`后台进程组(background process group)`
- 如果一个会话有一个控制终端，则它有一个前台进程组，其余进程组为后台进程组
- 无论何时键入终端的中断键，都会将中断信号发送到前台进程组的所有进程
- 五轮何时键入终端的退出键，都会将退出信号发送到前台进程组的所有进程
- 如果终端接口检测到`调制调节器/网络`断开连接，则将挂断信号发送到`控制进程/会话首进程`

# 9-7 前台进程组函数
```c
#include <unistd.h>

pid_t tcgetpgrp(int fd);
//与在fd上打开的终端相关联
//成功返回前台进程组ID，失败返回-1

pid_t tcsetpgrp(int fd, pid_t pgrpid);
//fd必须引用该会话的控制终端，pgrpid值为当前会话中一个进程组的ID
//成功返回0，失败返回-1
```

- 获得会话首进程的进程组ID
```c
#include <termios.h>

pid_t tcgetsid(int fd);
//成功返回会话首进程的进程组ID，失败返回-1
```

# 9-8 作业控制
允许一个终端上启动多个作业(进程组)

# 9-9 shell执行程序
...

# 9-10 孤儿进程组
## 定义
- 该组中每个成员的父进程要么是该组的一个成员，要么不是改组所属会话的成员
- 一个进程组不是孤儿进程组的条件：该组中有一个进程，其父进程在属于同一会话的另一个组中

# 9-11 FreeBSD实现
...