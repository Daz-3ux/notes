```
2022.4.25
时间过得又快又慢，赶紧过去吧一切
```

# 12-1 Intro
- 详细讲述如何控制线程行为
- 介绍线程属性和同步原语属性
- 介绍同一进程多个线程之间如何保持数据私有
- 讨论基于进程的系统调用如何与线程进行交互

# 12-2 线程限制
使用限制的意义：增强应用程序在不同的操作系统之间的可移植性
![在这里插入图片描述](https://img-blog.csdnimg.cn/28faae16fdda443daa1321dd17fb5baf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeXBkLg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/5e90942144e84f81be25d1a259b0b1eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeXBkLg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)



# 12-3 线程属性
##  对象属性
`pthread接口`允许我们通过设置每个对象关联的不同属性来细调**线程**和**同步对象**之间的行为
1. 每个**对象**与它自己的**属性对象**进行关联。
    - 一个属性对象可以代表多个属性。
    - 属性对象对应用程序是不透明的，可增强可移植性
    - 需要提供相应函数来管理属性对象
2. 初始化函数
3. 销毁对象属性函数：若初始化函数分配了与属性对象关联的资源，销毁函数负责释放这些资源
4. 每个属性都有一个从属性对象中获取属性值的函数
5. 每个属性都有一个设置属性值的函数

- `pthread_create`的参数可以为指向`pthread_attr_t`结构的指针
    - 此结构初始化后所包含的就是**操作系统实现支持的所有线程属性的默认值**
    - 此结构反初始化后会释放初始化动态分配的空间(有的话)，并且用无效的值初始化属性对象
```c
#include <pthread.h>

int pthread_attr_init(pthread_attr_t *attr);

int pthread_attr_destory(pthread_attr_t *attr);
//成功返回0，失败返回错误编号
```

## 分离线程PLUS：
    - 对某个线程的终止状态不感兴趣的话，可以使用pthread_detach函数让操作系统在线程退出时收回它所用的资源
    - 如果在创建线程时就不关心它的终止状态，可以让线程一开始就处于分离状态：通过修改`pthread_attr_t`中的`detachstate`线程属性
    - `detachestate`合法值：
        1. `PTHREAD_CREATE_DETACHED`：以分离状态启动进程
        2. `PTHREAD_CREATE_JOINABLE`：正常启动进程，应用可获取线程的终止状态
```c
#include <pthread.h>

int pthread_attr_getdetachstate(const pthread_attr_t *restrict attr.
                                int *detachstate)；
//获取当前detachstate属性

int pthread_attr_setdetachstate(pthread_attr_t *attr, int *detachstate);
//设置detachstate值
```

```c
/*以分类状态创建线程一例*/
int makethread(void *(*fn)(void *), void *arg)
{
    int err;
    pthread_t tid;
    pthread_attr_t attr;

    err = pthread_attr_init(&attr);
    if(err != 0){
        return(err);
    }
    err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    if(err == 0) {
        err = pthread_create(&tid, &attr, fn, arg);
    }
    err = pthread_attr_destroy(&attr);
    if(err != 0){
        //do something
        return 0;
    }
    return(err);
}
```

## 管理栈属性
```c
#include <pthread.h>

int pthread_attr_getstack(const pthread_attr_t *restrict attr, 
                            void **restrict stackaddr,
                            size_t *restrict stacksize)

int pthread_attr_setstack(pthread_attr_t *attr,
                            void *stackaddr,
                            size_t stacksize);
```

- 对于线程：虚地址空间大小是固定的，且被**所有线程栈**共享
- 若**线程栈**的虚地址空间用完了，可使用`malloc`或`mmap`来为可替代的栈分配空间，且使用`pthread_attr_setstack`函数来改变**新建线程**的栈位置
- `stackaddr`线程属性被定义为栈的**最低内存地址**，但不一定是**栈的开始位置**：取决于栈是从高地址开始增长或从低地址开始增长

- 读取/设置 stacksize
想要改变默认的栈大小，但又不想自己处理线程栈的分配问题：`pthread_attr_setstacksize()`就很有用
```c
#include <pthread.h>

int pthread_attr_getstacksize(const pthread_attr_t *restrict attr, size_t *restrict stacksize);

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
//成功返回0，错误返回错误编号
```

- `stacksize`不能小于`PTHREAD_STACK_MIN`

- `guardsize`控制着线程栈末尾之后用以避免栈溢出的**扩展内存**的大小
    - 常用值为系统页大小
    - 可设置为0：不提供警戒缓冲区
    - 修改`stackaddr`后，系统会让我们自己去管理栈，会使警戒缓冲区无效，相等于置0
```c
#include <pthread.h>

int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,
                                size_t *restrict guardsize);

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t guardsize);
```
- `guardsize`属性被修改，操作系统可能把它取为页大小的整数倍
- 若线程的栈指针溢出到警戒区域，应用程序就可能通过信号接收到其出错信息 





# 12-4 同步属性
线程具有属性，线程的**同步对象**也有属性

## 12-4.1 互斥量属性

## 12-4.2 读写锁属性

## 12-4.3 条件变量属性

## 12-4.4 屏障属性