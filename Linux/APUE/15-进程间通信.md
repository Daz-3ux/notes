# 进程间通信
- InterProcess Communication
- IPC
![在这里插入图片描述](https://img-blog.csdnimg.cn/37d7fac4443247f4ac336f6b1dd1a30e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeXBkLg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

- 经典IPC：
    - 管道
    - FIFO
    - 消息队列
    - 信号量
    - 共享存储

# 15-2 管道



# 15-3 函数popen和pclose



# 15-4 协同进程



# 15-5 FIFO



# 15-6 XSI IPC
- 三种XSI IPC：
    - 消息队列
    - 信号量
    - 共享存储器

## 标志符和键

### identifier and key
- 标识符：每个内核的IPC结构都用一个非负整数的**标识符**加以引用
    - 标识符是IPC对象的**内部名**
- 键：每个IPC对象都与一个**键**相关联
    - 将这个键作为该对象的**外部名**
    - 无论何时创建IPC结构，都应指定一个键
    - 键的数据类型为key_t，定义在`<sys/types/h>`

###  多种方法使客户进程和服务器进程在同一IPC上汇聚
- 使用指定键IPC_PRIVATE
- 在一个公共头文件中定义一个客户进程和服务器进程都认可的键
- 客户进程和服务器进程认同一个路径名和项目ID + ftok()函数调用

### ftok()
```c
#include<sys/ipc.h>

key_t ftok(const char *path, int id);
//成功返回键，出错返回-1
```

### tips
确保创建一个新的IPC结构：
- 在flags中指定`IPC_CREAT`与`IPC_CREAT`
- 若IPC结构已存在则报错

## 权限结构
- XSI IPC为每一个IPC结构关联了一个 `ipc_perm` 结构
- 该结构规定了**权限和所有者**

### 值：
- 在创建IPC结构时，对所有字段都赋初值
- msgctl()可修改uid字段
- semctl()可修改gid字段
- shmctl()可修改mode字段
- 若需修改，调用进程必须为IPC结构的创建者或者超级用户（修改这些字段类似于文件调用chmod）

### mode字段
- 对于任何IPC结构都不存在执行权限
- **消息队列和共享存储**使用术语“读” “写”
- **信号量**          使用术语“读” “更改”

<table>
   <tr>
      <td>权限  位 </td>
   </tr>
   <tr>
      <td></td>
   </tr>
   <tr>
      <td>用户读            0400 </td>
   </tr>
   <tr>
      <td>用户写(更改)  0200 </td>
   </tr>
   <tr>
      <td></td>
   </tr>
   <tr>
      <td>组读           0040 </td>
   </tr>
   <tr>
      <td>组写(更改)  0020</td>
   </tr>
   <tr>
      <td></td>
   </tr>
   <tr>
      <td>其他读           0004 </td>
   </tr>
   <tr>
      <td>其他写(更改) 0002 </td>
   </tr>
</table>

## 结构限制
- 所有三种形式的XSI IPC都有内置限制
- 大多数限制可以通过重新配置内核来改变

## 优点与缺点   
### 问题：
- IPC是在系统范围内起作用的，没有引用计数
- IPC结构在文件系统中没有名字

### 不同IPC之间特性比较
![在这里插入图片描述](https://img-blog.csdnimg.cn/839ab456681e4955bb9659312df814b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeXBkLg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

- “无连接”： 无需先调用某种形式的打开函数就能发送消息的能力
- “流控制”： 如果系统资源(缓存区)短缺，或者若接受进程不能再接收更多消息，则发送进程就要休眠。(当流控制条件消失时，发送进程应自动唤醒)
