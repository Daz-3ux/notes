# 11-1 intro
- 学习如何使用多个**控制线程**在**单进程**环境中执行多个任务
- 学习处理一致性问题

# 11-2 线程概念
- 使用**多个线程**在**单进程环境**中执行多个任务，每个线程处理各自**独立**的任务
- 好处：
    - 通过为每种事件类型分配单独的处理进程，可以简化处理异步事件的代码
    - 多个线程可以**自动地**访问相同的存储地址空间和文件描述符
    - 提高程序吞吐量
    - 改善响应时间
- 一个进程的所有信息对该进程的所有线程都是**共享的**

# 11-3 线程标识
- 进程ID在整个系统中都是唯一的
- 线程ID只在其所属上下文中有意义

- 使用`pthread_t`数据类型来表示线程ID
- 为保证可移植性：
    - 使用函数比较两个线程ID
```c
#include <pthread.h>

int pthread_equal(pthread_t tidl, pthread_t tid2);
//相等返回非0，否则返回0
```
    - 使用函数获取自身线程ID
```c
#include <pthread.h>

pthread_t pthread_self(void);
//返回调用线程的IDF(always succeeds)
```

# 11-4 线程创建
- 新增线程通过如下函数创建
```c
#include <pthread.h>
int pthread_create (pthread_t *restrict tidp, const pthread_attr_t *restrict attr, /
                    void *(*start_rtn) (void*), void *restrict arg);
//成功返回0，否则返回错误编号
```
- `pthread_create`成功返回时：
    - 新创建线程的 线程ID 会被设置为`tidp`指向的内存单元
    - `attr`参数用于定制各种不同的线程属性
    - 新创建的线程从`start_rtn`函数的地址开始运行
    - 若向传递的参数大于一个，那么就需要把这些参数放到一个结构体中，然后把结构地址作为`arg`参数传入

- 线程创建时并不能保证哪个线程先运行：新创建的线程还是调用线程？(类似fork后父子进程)
- **pthread函数**在调用失败时通常返回错误码，而非设置errno
    - 但线程会提供errno副本，保证兼容现有errno函数
    - 在线程中这么做时为了**清晰整洁**