# 11.1 系统虚拟化技术概述

## 11.1.1 系统虚拟化及其组成部分
- 系统虚拟化技术能够在一台物理主机上创建多个`虚拟机`
  - 技术核心为`虚拟机监控器`
  - 虚拟化监控机运行在CPU的最高特权级,直接控制着硬件,并为上层软件提供虚拟的硬件接口,让其以为自己运行在真实的物理主机上

- 系统虚拟化技术主要包含三方面
  - `CPU虚拟化`
    - 为虚拟机提供`虚拟处理器(vCPU)`的抽象并执行其指令的过程
    - 虚拟机监控器直接运行在物理主机上,使用物理 ISA,并向上层虚拟机提供虚拟 ISA
    - 虚拟 ISA 可以与物理 ISA 相同,也可以完全不同
  - `内存虚拟化`
    - 虚拟机监控器负责管理所有物理内存
    - 引入一层新的地址空间:`客户物理地址`
    - 提供新的翻译机制,将虚拟机中`假`的物理地址翻译成`真`的物理地址
  - `I/O虚拟化`
    - 虚拟机监控器负责提供虚拟的 I/O 设备支持
    - 将所有对虚拟设备的访问映射为对物理设备的访问

## 11.1.2 虚拟机监控器的类型
- Type1: 虚拟机直接运行在最高特权级,就像一个操作系统
- Type2: 依托于宿主操作系统,比如QEMU
![](https://i.imgur.com/AT5zKyM.png)

# 11.2 CPU虚拟化
## 11.2.1 下陷和模拟

## 11.2.2 可虚拟化结构与不可虚拟化结构
- `敏感指令`和`特权指令`
  - 特权指令:在用户态执行会触发下陷的指令
    - 主动触发下陷的指令
    - 不允许在用户态执行的指令
  - 敏感指令:系统管理物理资源或更改 CPU 状态的指令
    - 读写特殊寄存器或执行特殊指令以更改CPU状态
    - 读写敏感内存
    - 执行I/O指令
- `可虚拟化架构`的特征:所有的敏感指令都是特权指令(在非特权执行时都会触发下陷)
  - 不满足此定义的架构则为不可虚拟化架构

-------
- 五种弥补不可虚拟化架构缺陷的方法
## 11.2.3 解释执行
- 依次取出虚拟机内的每一条指令,用软件模拟这条指令的执行效果
- 不依赖于下陷,所有的指令都被虚拟机监控器模拟运行
- 造成巨大的性能开销

## 11.2.4 动态二进制翻译
- 解释执行的开销主要来自于不加区分的模拟每一条指令
- 动态二进制翻译将多条指令直接翻译为对应的模拟函数,然后直接执行翻译后的代码,提高了性能

## 11.2.5 扫描和翻译
- 如果宿主机的指令与虚拟机相同,非敏感指令无需模拟,可直接在CPU中执行
- 因此:只让敏感指令下陷,其他指令直接执行

## 11.2.6 半虚拟化机制
- 以上三种无需修改客户虚拟机源码的方式为`全虚拟化(full virtualization)`技术
- 允许修改客户虚拟机源码的技术为`半虚拟化(paravirtualization)`
- 优势
  - 高性能
  - 缓解`语义鸿沟(semantic gap)`
    - 不使用半虚拟化技术时虚拟机监控器只能看到内存中的二进制数据,难以将其转换为有意义的语义

## 11.2.7 硬件虚拟化技术
- 在已有的 CPU 特权级下新增了两个模式
  - 根模式: `root mode`
  - 非根模式: `non-root mode`

## 11.2.8 小结
![](https://i.imgur.com/6WeYMUz.png)
---

# 11.3 内存虚拟化

## 11.3.1 影子页表机制

## 11.3.2 影子页表的缺页异常处理流程

## 11.3.3 直接页表映射机制

## 11.3.4 两阶段地址翻译机制

## 11.3.5 换页和内存气球机制

## 11.3.6 小结

# # 11.4 I/O 虚拟化

## 11.4.1 软件模拟方法

## 11.4.2 半虚拟化技术

## 11.4.3 设备直通

## 11.4.4 小结

# 11.5 中断虚拟化
