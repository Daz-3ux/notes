# 虚拟内存与物理地址
- CPU将会虚拟地址转为物理地址
  - 在引入虚拟地址后,程序通过使用`虚拟地址`访问存储在`内存`中的数据和代码
  - 程序执行使,CPU将虚拟地址转换为物理地址(地址翻译),再通过物理地址访问物理内存
- `内存管理单元`:
  - MMU: Memory Management Unit
  - 负责虚拟地址到物理地址的转换
  - 但需要访问物理内存设备时,MMU翻译出的物理地址会通过`总线`传到相应的物理内存设备,完成IO
  - 为了加速地址的翻译:现代CPU均引入了`转址旁路缓存`(TLB)
    - TLB为MMU的内部单元

# 分段和分页机制
- MMU将虚拟地址翻译为物理地址的主要机制
  - `分段机制`
  - `分页机制`

- 分段机制
  - out:容易造成`外部碎片`
  - 操作系统以"`段`"(一段连续的物理内存)来`管理/分配`内存
  - CPU访问虚拟地址空间中的某一个`段`的时候,MMU会通过查询`段表`得到对应的物理内存区域
  - 该机制下虚拟地址由两个部分组成
    - 段号
    - 段内地址
  - 段表
    - 存储`段起始地址`和`段长`
  - 翻译过程:
    - MMU首先通过`段表基址寄存器`寻找到段表位置,结合段号,定位段的信息
    - 取出段的起始地址,加上段内地址(偏移量),得到物理地址

- 分页机制
  - 被现代操作系统广泛采用
  - 虚拟地址与物理内存都被分为`连续的,等长`的虚拟页/物理页
  - 该机制下虚拟地址由两个部分组成
    - 虚拟页号
    - 页内偏移量
  - 物理资源更易管理,可有效避免外部碎片问题

![](https://i.imgur.com/ckKRkb7.png)

# 基于分页的虚拟内存
- 单页页表占用内存太大
  - 单级页表的每一项都需要存在
- 为了压缩页表大小
  - 操作系统引入了`多级结构`的页表,以满足虚拟内存在空间高效性方面的要求
  - 虚拟页号对应的任一级`页表`的某一个`条目`为`空`时,该条目对应的下一级页表不需要存在

## AArch64 架构下的4级页表
- AArch64设置:虚拟地址低48位参与地址翻译,页表级数为4级,虚拟页大小为4KB

- 在此设置下,物理内存被划分为连续的,4KB大小的物理页,一个虚拟地址对应一个物理页
  - 页的大小为4KB:虚拟地址的`低12位`对应于`页内偏移量`

- 整个页表的`起始地址`(物理地址)存储在一个特殊的`寄存器`中,对于Linux,`页表基地址寄存器`是`TTBR0_EL1`
  - `第0级(顶级)页表`有且只有`一个`页表页,页表基地址寄存器存储该页的`物理地址`
  - 其余每一级页表拥有若干个页表页
  - 每个`页表项`占用8个字节
    - 存储物理地址和对应的访问权限
    - 一个页表页包含512个页表项
    - 512对应`9位`,所以虚拟地址对应于每一级页表的索引都是9位

