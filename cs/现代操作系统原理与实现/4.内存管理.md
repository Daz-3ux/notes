# 虚拟内存与物理地址
- CPU将会虚拟地址转为物理地址
  - 在引入虚拟地址后,程序通过使用`虚拟地址`访问存储在`内存`中的数据和代码
  - 程序执行使,CPU将虚拟地址转换为物理地址(地址翻译),再通过物理地址访问物理内存
- `内存管理单元`:
  - MMU: Memory Management Unit
  - 负责虚拟地址到物理地址的转换
  - 但需要访问物理内存设备时,MMU翻译出的物理地址会通过`总线`传到相应的物理内存设备,完成IO
  - 为了加速地址的翻译:现代CPU均引入了`转址旁路缓存`(TLB)
    - TLB为MMU的内部单元

# 分段和分页机制
- MMU将虚拟地址翻译为物理地址的主要机制
  - `分段机制`
  - `分页机制`

- 分段机制
  - out:容易造成`外部碎片`
  - 操作系统以"`段`"(一段连续的物理内存)来`管理/分配`内存
  - CPU访问虚拟地址空间中的某一个`段`的时候,MMU会通过查询`段表`得到对应的物理内存区域
  - 该机制下虚拟地址由两个部分组成
    - 段号
    - 段内地址
  - 段表
    - 存储`段起始地址`和`段长`
  - 翻译过程:
    - MMU首先通过`段表基址寄存器`寻找到段表位置,结合段号,定位段的信息
    - 取出段的起始地址,加上段内地址(偏移量),得到物理地址

- 分页机制
  - 被现代操作系统广泛采用
  - 虚拟地址与物理内存都被分为`连续的,等长`的虚拟页/物理页
  - 该机制下虚拟地址由两个部分组成
    - 虚拟页号
    - 页内偏移量
  - 物理资源更易管理,可有效避免外部碎片问题

![](https://i.imgur.com/ckKRkb7.png)

# 基于分页的虚拟内存
- 单页页表占用内存太大
  - 单级页表的每一项都需要存在
- 为了压缩页表大小
  - 操作系统引入了`多级结构`的页表,以满足虚拟内存在空间高效性方面的要求
  - 虚拟页号对应的任一级`页表`的某一个`条目`为`空`时,该条目对应的下一级页表不需要存在

## AArch64 架构下的4级页表
- AArch64设置:虚拟地址低48位参与地址翻译,页表级数为4级,虚拟页大小为4KB

- 在此设置下,物理内存被划分为连续的,4KB大小的物理页,一个虚拟地址对应一个物理页
  - 页的大小为4KB:虚拟地址的`低12位`对应于`页内偏移量`

- 整个页表的`起始地址`(物理地址)存储在一个特殊的`寄存器`中,对于Linux,`页表基地址寄存器`是`TTBR0_EL1`
  - `第0级(顶级)页表`有且只有`一个`页表页,页表基地址寄存器存储该页的`物理地址`
  - 其余每一级页表拥有若干个页表页
  - 每个`页表项`占用8个字节
    - 存储物理地址和对应的访问权限
    - 一个页表页包含512个页表项
    - 512对应`9位`,所以虚拟地址对应于每一级页表的索引都是9位

## 加速地址翻译的重要硬件:TLB
- Translation lookaside buffer
- 多级页表会显著压缩页表的大小,但会导致地址翻译时长的增加("`时间换空间`")
- 一次地址翻译可能会导致多次物理内存访问
  - 为了减少地址翻译的访存次数:引入`地址旁路缓存(TLB)`部件来加速地址翻译的过程

- **TLB缓存了虚拟页号到物理页号的映射关系**
  - TLB可简化为存储着键值对的哈希表:键为虚拟页号,值为物理页号
  - MMU会先把虚拟页号作为键去查询TLB中的缓存项,若找到就可以直接获得物理页号而无需查表
  - TLB能够直接完成地址翻译:`TLB命中`

- TLB硬件采用`分层`的架构(类似CPU缓存),分为来L1和L2两层
  - `L1`分为`数据TLB`和`指令TLB`

- 由于`局部性`作用,简单的TLB管理方式可以获得较高的`TLB命中率`

- OS在进行`页表切换(应用程序切换)`时需主动刷新TLB
  - 防止TLB不及时刷新指向错误结果
  - AArch64提供`ASID`,x86-64提供`PCID`
    - 应用程序的`身份标签`
    - 使得TLB中属于不同应用的缓存项可以被区分开
  - 多粒度刷新TLB
    - 刷新全部TLB
    - 刷新指定ASID的TLB
    - 刷新指定虚拟地址的TLB

## 换页与缺页异常
- 换页与缺页机制

## 页替换策略
- MIN策略/OPT策略
  - 同名词:`最优策略`
  - 理论最优但难以实现
- FIFO策略
  - `先进先出`
  - 直观且开销低,但使用时表现不佳
  - 几乎不会被现代OS使用
- Second Chance策略
  - 维护一个`访问标志位`
    - 访问寻找换出页时若有标记则将其标记清零并置于队尾,无标记则将其换出
  - 性能优于FIFO,极端情况下等于FIFO
- LRU策略
  - Least Recently Used
  - 优先换出最久未被访问页
  - 开销较大:需CPU时刻记录访问了哪些物理页
- MRU策略
  - Most Recently Used
  - 优先换出最近被访问页
  - 基于程序不会反复的访问相同的地址:"例如播放视频"
- 时钟算法策略
- 不需要从队头到队尾的Second Chance策略

## 工作集模式
- 若选择的替换策略与实际的工作负载不匹配,则有可能导致颠箍(thrashing)现象
  - 造成严重性能损失
- 工作集的概念依旧指导着现代OS:优先将非工作集的页换出
- 高效实现工作集:工作集时钟算法

# 虚拟内存功能
- 虚拟内存的抽象带来了很多功能:
## 共享内存


## 写时拷贝
- AB进程共享一块只读内存,A一直不变,B`写`了一下内存,这`时`OS会新`拷贝`一份**可读可写**的内存给B
- 写时拷贝可以节约物理内存资源,避免内存拷贝带来的时间和空间开销

## 内存去重
- OS扫描到具有相同内容的物理页后通过写时拷贝的方式使多个虚拟页映射到这个物理页
- Linux有实现其:KSM
- 可能会对应用程序访存时延造成影响
  - 当应用程序去访问一个被去重的内存页时,既会触发`缺页异常`,又会导致`内存拷贝`
- 还可能造成安全性问题

## 内存压缩
- 在内存中压缩不常用资源,比换出内存到磁盘上更快
- Linux实现:zswap

## 大页
- 2MB甚至1GB
- 好处
  - 减少TLB缓存项的使用,提高TLB命中率
  - 可以减少页表的级数,从而提升查询页表的效率
- 弊端
  - 可能造成内存资源浪费
  - 增加系统管理内存的复杂度
    - Linux中就存在与大页相关的漏洞

# 物理内存分配和管理
## why
- 物理内存分配器要追求更高的`内存资源利用率`,尽可能减少资源浪费
- 内存碎片分为`外部碎片`与`内部碎片`

## 伙伴系统
- buddy system
- 是将物理内存划分成连续的块,以块作为基本单位进行分配
  - 不同块的大小可以不同,但每个块都由一个或多个连续的物理页组成,物理页的数量必须是2的n次幂
- 大的块可以`分裂`为两半,互为伙伴块,小的空闲伙伴块可以`合并`
  - 分裂与合并操作均为`级联`的
- 由`空闲链表数组`实现伙伴系统
- 能够高效管理物理内存页,发展沿用至今

## SLAB分配器
- SLAB,SLUB,SLOB:统称SLAB分配器
- SLAB分配器是Linux内核默认使用的分配器

## 常用的空闲链表
- 伙伴系统
- SLAB
- 隐式空闲链表
- 显式空闲链表
- 分离空闲链表

