# 虚拟内存与物理地址
- CPU将会虚拟地址转为物理地址
  - 在引入虚拟地址后,程序通过使用`虚拟地址`访问存储在`内存`中的数据和代码
  - 程序执行使,CPU将虚拟地址转换为物理地址(地址翻译),再通过物理地址访问物理内存
- `内存管理单元`:
  - MMU: Memory Management Unit
  - 负责虚拟地址到物理地址的转换
  - 但需要访问物理内存设备时,MMU翻译出的物理地址会通过`总线`传到相应的物理内存设备,完成IO
  - 为了加速地址的翻译:现代CPU均引入了`转址旁路缓存`(TLB)
    - TLB为MMU的内部单元

# 分段和分页机制
- MMU将虚拟地址翻译为物理地址的主要机制
  - `分段机制`
  - `分页机制`

- 分段机制
  - out:容易造成`外部碎片`
  - 操作系统以"`段`"(一段连续的物理内存)来`管理/分配`内存
  - CPU访问虚拟地址空间中的某一个`段`的时候,MMU会通过查询`段表`得到对应的物理内存区域
  - 该机制下虚拟地址由两个部分组成
    - 段号
    - 段内地址
  - 段表
    - 存储`段起始地址`和`段长`
  - 翻译过程:
    - MMU首先通过`段表基址寄存器`寻找到段表位置,结合段号,定位段的信息
    - 取出段的起始地址,加上段内地址(偏移量),得到物理地址

- 分页机制
  - 被现代操作系统广泛采用
  - 虚拟地址与物理内存都被分为`连续的,等长`的虚拟页/物理页
  - 该机制下虚拟地址由两个部分组成
    - 虚拟页号
    - 页内偏移量
  - 物理资源更易管理,可有效避免外部碎片问题

![](https://i.imgur.com/ckKRkb7.png)

# 基于分页的虚拟内存
- 单页页表占用内存太大
  - 单级页表的每一项都需要存在
- 为了压缩页表大小
  - 操作系统引入了`多级结构`的页表,以满足虚拟内存在空间高效性方面的要求
  - 虚拟页号对应的任一级`页表`的某一个`条目`为`空`时,该条目对应的下一级页表不需要存在

## AArch64 架构下的4级页表
- AArch64设置:虚拟地址低48位参与地址翻译,页表级数为4级,虚拟页大小为4KB

- 在此设置下,物理内存被划分为连续的,4KB大小的物理页,一个虚拟地址对应一个物理页
  - 页的大小为4KB:虚拟地址的`低12位`对应于`页内偏移量`

- 整个页表的`起始地址`(物理地址)存储在一个特殊的`寄存器`中,对于Linux,`页表基地址寄存器`是`TTBR0_EL1`
  - `第0级(顶级)页表`有且只有`一个`页表页,页表基地址寄存器存储该页的`物理地址`
  - 其余每一级页表拥有若干个页表页
  - 每个`页表项`占用8个字节
    - 存储物理地址和对应的访问权限
    - 一个页表页包含512个页表项
    - 512对应`9位`,所以虚拟地址对应于每一级页表的索引都是9位

# 加速地址翻译的重要硬件:TLB
- 多级页表会显著压缩页表的大小,但会导致地址翻译时长的增加("`时间换空间`")
- 一次地址翻译可能会导致多次物理内存访问
  - 为了减少地址翻译的访存次数:引入`地址旁路缓存(TLB)`部件来加速地址翻译的过程

- **TLB缓存了虚拟页号到物理页号的映射关系**
  - TLB可简化为存储着键值对的哈希表:键为虚拟页号,值为物理页号
  - MMU会先把虚拟页号作为键去查询TLB中的缓存项,若找到就可以直接获得物理页号而无需查表
  - TLB能够直接完成地址翻译:`TLB命中`

- TLB硬件采用`分层`的架构(类似CPU缓存),分为来L1和L2两层
  - `L1`分为`数据TLB`和`指令TLB`

- 由于`局部性`作用,简单的TLB管理方式可以获得较高的`TLB命中率`

- OS在进行`页表切换(应用程序切换)`时需主动刷新TLB
  - 防止TLB不及时刷新指向错误结果
  - AArch64提供`ASID`,x86-64提供`PCID`
    - 应用程序的`身份标签`
    - 使得TLB中属于不同应用的缓存项可以被区分开
  - 多粒度刷新TLB
    - 刷新全部TLB
    - 刷新指定ASID的TLB
    - 刷新指定虚拟地址的TLB

# 换页与缺页异常