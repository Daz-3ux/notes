# 8.1 互斥锁
## 8.1.1 临界区问题
- `临界区`:保证`互斥访问`共享资源的`代码区域`
```c
while(true) {
  // 申请进入临界区

  // 临界区部分

  // 标示退出临界区

  // 其他代码
}
```

- 解决临界区问题的`三个条件`
  - `互斥访问`:在同一时刻只有一个线程可以执行临界区
  - `有限等待`:当一个线程申请进人临界区之后,必须在有限的时间内获得许可并进入临界区,不能无限等待
  - `空闲让进`:当没有线程在执行临界区代码时,必须在申请进人临界区的线程中选择一个线程允许其执行临界区代码,保证程序执行的进展

## 8.1.2 硬件实现:关闭中断
- 单核中
  - 在单核中关闭中断意味着当前执行的线程不能再被其他线程抢占
  - 进入前关闭中断,离开时开启中断

## 8.1.3 软件实现:皮特森算法

## 8.1.4 软硬件协同:使用原子操作实现互斥锁
- 原子操作
  - 常见原子操作
    - 比较与置换 : Compare-And-Swap `(CAS)`
    - 拿取并累加 : Fetch-And_Add `(FAA)`

- 互斥锁抽象
  - 自旋锁:
    - spin lock
    - 利用原子 CAS 实现
    - 自旋锁不能保证有限等待,不具有`公平性`
    - 在竞争程度低时非常高效
  - 排号自旋锁
    - ticket lock
    - 利用原子 FAA 实现
    - 更加公平的策略:按照竞争者申请锁的顺序传递锁

# 8.2 条件变量
- 使用`挂起/唤醒机制`避免`循环忙等`: busy looping

## 8.2.1 条件变量的使用
- 接口:
  - cond_wait(): 挂起当前线程
    - 参数为`条件变量`与`互斥锁`
    - 调用时需确保当前`已获取`搭配的互斥锁(处于临界区之中)
    - `原子操作`:将当前线程加入等待队列+挂起当前线程并放锁
  - cond_signal(): 唤醒等待在该条件变量上的线程
    - 参数为`条件变量`
    - 在临界区外唤醒线程需特别小心:可能会产生丢失唤醒问题
    - 唤醒一个等待在条件变量上的线程
- 条件变量必须搭配一个`互斥锁`一起使用
  - **互斥锁解决临界区问题**
  - **条件变量通过提供挂起/唤醒机制来避免循环等待**

## 8.3 信号量
- 信号量的语义
```c
void wait(int *S) {
  while(*S <= 0) {
    ; // 循环忙等
  }
  *S = *S - 1;
}

void signal(int *S) {
  *S = *S + 1;
}
```

## 8.3.1 信号量的使用
- 信号量是辅助控制多个线程访问`有限数量的共享资源`的
- 只允许三个操作修改其值
  - 初始化
  - wait
  - signal

## 8.3.2 信号量的实现
- 互斥锁 vs. 信号量
  - `二元信号量`:值只在 0 与 1 之间变换
    - 与互斥锁类似
    - 但互斥锁有`拥有者`这一概念,二元信号量则没有
    - 互斥锁由同一线程加锁放锁,而二元信号量允许不同线程执行wait与signal
  - `计数信号量`
  - 互斥锁保证多个线程对同一共享资源的互斥访问,信号量用于协调多个线程对一系列共享资源的有序操作

- 条件变量 vs. 信号量
  - 信号量利用条件变量实现了更高层级的抽象

# 8.4 读写锁
- 保证`写`共享数据的线程与`读`共享数据的线程之间不会相互产生干扰     

## 8.4.1 读写锁的使用
- 读锁只保证读者与写者互斥
- 写锁保证读者与写者互斥,写者与写者互斥
- 读写锁除基本加锁放锁,有的实现还可以升级降级锁(读锁变写锁,写锁变读锁)

## 8.4.2 读写锁的实现
- 读写锁具有倾向性问题
  - 偏向读者的读写所:保证读者的并行性
  - 偏向写这的读写所:避免写着陷入无限等待
- 

# RCU

## 订阅/发布机制

## 宽限期

# 管程

# 同步带来的问题

## 死锁

## 活锁

## 优先级反转

## Linux中的`futex`

