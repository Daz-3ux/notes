# 8.1 互斥锁
## 8.1.1 临界区问题
- `临界区`:保证`互斥访问`共享资源的`代码区域`
```c
while(true) {
  // 申请进入临界区

  // 临界区部分

  // 标示退出临界区

  // 其他代码
}
```

- 解决临界区问题的`三个条件`
  - `互斥访问`:在同一时刻只有一个线程可以执行临界区
  - `有限等待`:当一个线程申请进人临界区之后,必须在有限的时间内获得许可并进入临界区,不能无限等待
  - `空闲让进`:当没有线程在执行临界区代码时,必须在申请进人临界区的线程中选择一个线程允许其执行临界区代码,保证程序执行的进展

## 8.1.2 硬件实现:关闭中断
- 单核中
  - 在单核中关闭中断意味着当前执行的线程不能再被其他线程抢占
  - 进入前关闭中断,离开时开启中断

## 8.1.3 软件实现:皮特森算法

## 8.1.4 软硬件协同:使用原子操作实现互斥锁
- 原子操作
  - 常见原子操作
    - 比较与置换 : Compare-And-Swap `(CAS)`
    - 拿取并累加 : Fetch-And_Add `(FAA)`

- 互斥锁抽象
  - 自旋锁:
    - spin lock
    - 利用原子 CAS 实现
    - 自旋锁不能保证有限等待,不具有`公平性`
    - 在竞争程度低时非常高效
  - 排号自旋锁
    - ticket lock
    - 利用原子 FAA 实现
    - 更加公平的策略:按照竞争者申请锁的顺序传递锁

# 8.2 条件变量
- 使用`挂起/唤醒机制`避免`循环忙等`: busy looping

## 8.2.1 条件变量的使用
- 接口:
  - cond_wait(): 挂起当前线程
    - 参数为`条件变量`与`互斥锁`
    - 调用时需确保当前`已获取`搭配的互斥锁(处于临界区之中)
    - `原子操作`:将当前线程加入等待队列+挂起当前线程并放锁
  - cond_signal(): 唤醒等待在该条件变量上的线程
    - 参数为`条件变量`
    - 在临界区外唤醒线程需特别小心:可能会产生丢失唤醒问题
    - 唤醒一个等待在条件变量上的线程
- 条件变量必须搭配一个`互斥锁`一起使用
  - **互斥锁解决临界区问题**
  - **条件变量通过提供挂起/唤醒机制来避免循环等待**

## 8.3 信号量
- 信号量的语义
```c
void wait(int *S) {
  while(*S <= 0) {
    ; // 循环忙等
  }
  *S = *S - 1;
}

void signal(int *S) {
  *S = *S + 1;
}
```

## 8.3.1 信号量的使用
- 信号量是辅助控制多个线程访问`有限数量的共享资源`的
- 只允许三个操作修改其值
  - 初始化
  - wait
  - signal

## 8.3.2 信号量的实现
- 互斥锁 vs. 信号量
  - `二元信号量`:值只在 0 与 1 之间变换
    - 与互斥锁类似
    - 但互斥锁有`拥有者`这一概念,二元信号量则没有
    - 互斥锁由同一线程加锁放锁,而二元信号量允许不同线程执行wait与signal
  - `计数信号量`
  - 互斥锁保证多个线程对同一共享资源的互斥访问,信号量用于协调多个线程对一系列共享资源的有序操作

- 条件变量 vs. 信号量
  - 信号量利用条件变量实现了更高层级的抽象

# 8.4 读写锁
- 保证`写`共享数据的线程与`读`共享数据的线程之间不会相互产生干扰     

## 8.4.1 读写锁的使用
- 读锁只保证读者与写者互斥
- 写锁保证读者与写者互斥,写者与写者互斥
- 读写锁除基本加锁放锁,有的实现还可以升级降级锁(读锁变写锁,写锁变读锁)

## 8.4.2 读写锁的实现
- 读写锁具有倾向性问题
  - 偏向读者的读写所:保证读者的并行性
  - 偏向写这的读写所:避免写着陷入无限等待
- 

# 8.5 RCU
- Read-Copy Update
- 有效减少读者在关键路径上的性能开销
- 主流的CPU提供对`地址对齐`的单一读写操作的原子性保证:单拷贝原子性

## 8.5.1 订阅/发布机制
- 保证顺序的读操作/写操作

## 8.5.2 宽限期
- 用来确定何时回收资源
- 宽限期用于描述从写者更新指针到最后一个可能观察到旧数据的读者离开的这段时间
- 在宽限期中,由于可能有读者在使用旧的数据,因此旧数据不能被回收。而当宽限期结束之时,没有读者会再观察到旧数据了,此时旧数据可以被回收

# 8.6 管程
- Monitor
- 两部分组成
  - 共享的数据
  - 操作共享数据的函数
- 保证同一时刻最多只有一个操作者能够进入管程的保护区域访问共享数据
- 高层次抽象

# 同步带来的问题
## 死锁
- 出现的四个必要条件:
  - 互斥访问
  - 持有并等待
  - 资源非抢占
  - 循环等待

## 活锁
- 并未发生阻塞,而是线程不断重复"尝试-失败-尝试-失败"的过程

## 优先级反转
- 避免优先级反转
  - 使用`不可抢占临界区协议`: NCP
  - 使用`优先级继承协议`: PIP
    - 现代操作系统中更常用
  - 使用`优先级置顶协议`: PCP
    - 即时优先级置顶协议: IPCP
    - 原生优先级置顶协议: OPCP

## Linux中的`futex`
- Fast User-space muTEX
- 使用futex实现的互斥锁能够在竞争程度低时直接使用原子操作加锁
- 在竞争程度高时,应用程序能够通过系统调用挂起并等待被后续锁持有者唤醒

