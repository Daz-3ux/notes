# 8.1 互斥锁
## 8.1.1 临界区问题
- `临界区`:保证`互斥访问`共享资源的`代码区域`
```c
while(true) {
  // 申请进入临界区

  // 临界区部分

  // 标示退出临界区

  // 其他代码
}
```

- 解决临界区问题的`三个条件`
  - `互斥访问`:在同一时刻只有一个线程可以执行临界区
  - `有限等待`:当一个线程申请进人临界区之后,必须在有限的时间内获得许可并进入临界区,不能无限等待
  - `空闲让进`:当没有线程在执行临界区代码时,必须在申请进人临界区的线程中选择一个线程允许其执行临界区代码,保证程序执行的进展

## 8.1.2 硬件实现:关闭中断
- 单核中
  - 在单核中关闭中断意味着当前执行的线程不能再被其他线程抢占
  - 进入前关闭中断,离开时开启中断

## 8.1.3 软件实现:皮特森算法

## 8.1.4 软硬件协同:使用原子操作实现互斥锁
- 原子操作
  - 常见原子操作
    - 比较与置换 : Compare-And-Swap `(CAS)`
    - 拿取并累加 : Fetch-And_Add `(FAA)`

- 互斥锁抽象
  - 自旋锁:
    - spin lock
    - 利用原子CAS实现
    - 自旋锁不能保证有限等待,不具有`公平性`
    - 在竞争程度低时非常高效
  - 排号自旋锁
    - 利用原子FAA实现
    - ticket lock

# 8.2 条件变量

## 8.2.1 条件变量的使用

## 8.2.2 条件变量的实现

## 8.3 信号量

## 8.3.1 信号量的使用

## 8.3.2 信号量的实现

# 8.4 读写锁

## 8.4.1 读写锁的使用

## 8.4.2 读写锁的实现

# RCU

## 订阅/发布机制

## 宽限期

# 管程

# 同步带来的问题

## 死锁

## 活锁

## 优先级反转

## Linux中的`futex`

