# 进程
## 进程的状态
- 新生状态
  - `new`
  - 尚未初始化,初始化后迁移至`预备状态`
- 预备状态
  - `ready`
  - 可被调度执行,但还未被调度器选择
  - 被调度器选择执行后迁移至`运行状态`
- 运行状态
  - `running`
  - 调度器中断其执行并将其重新回放调度队列,就迁移至`预备状态`
  - 进程结束运行后,迁移至`终止状态`
  - 进程需等待外部条件,可放弃CPU并迁移至`阻塞状态`
- 阻塞状态
  - `blocked`
  - 完成外部事件后,迁移至`预备状态`
- 终止状态
  - `terminated`
  - 进程完成执行,不会再被调度

![](https://i.imgur.com/jDZxA69.png)

## 进程的内部空间布局
- 进程拥有独立的虚拟内存空间
  - 用户栈
    - 自顶向下扩展(从高地址向低地址扩展)
    - 栈底在高地址,栈顶在低地址
  - 代码库
    - 只读
  - 用户堆
    - 自底向上扩展(低地址到高地址)
    - 管理进程动态分配的内存
  - 数据和代码段
    - 数据段主要保存全局变量的值
    - 代码段保存进程执行所需要的代码
  - 内核部分
    - 每个进程的虚拟地址空间里都映射了相同的内核内存
    - 进程在内核态运行时,内核对其不可见
    - 进程进入内核态,才能访问内核内存
    - 内核部分也有内核需要的代码和数据段

## 进程控制快和上下文切换
- 每个进程通过一个数据结构保存它的相关进程状态:PCB
  - `进程控制块`:Process Control Block
- 进程的`上下文`
  - 包括进程运行时的`寄存器`状态
  - 能够用于保存和恢复一个进程在处理器上运行的状态
  - 当OS需要切换当前执行的进程时,就会使用`上下文切换`(context switch)机制
  - 线程出现后,调度和上下文切换的基本单位由进程变为了线程
![](https://i.imgur.com/b4Vqju8.png)

# Linux的进程操作
## 进程的创建:`fork()`
- 父进程与子进程的执行顺序是不确定的,完全取决于调度器的决策
- `写时拷贝`技术优化了fork的实现

## 进程的执行:`exec()`
- 用户需子进程执行与父进程完全不同的任务,为实现此目标,Linux提供了`exec`接口
- exec由一系列接口组成,存在多个变种,最全面的为`execve()`

## 进程管理
- 进程间的关系与进程树
  - Linux中进程都是通过fork创建的
  - 进程树根部是`init进程`
- 进程间监控:`wait`
  - 类似exec,有多个变种
  - 不仅是监控子进程,也可以回收已经运行结束的子进程和释放资源
  - 子进程终止但资源不释放:僵尸进程(zombie)
- 进程组和绘画
  - `进程组`是进程的集合
    - 一大作用为处理信号
  - `会话`是进程组的集合
    - 其将进程组分为`前台进程组`和`后台进程组`
    - `控制终端进程`是会话与外界进行交互的"窗口"
    - 会话和进程主要用于shell环境中的进程管理

# 线程
- 共享进程的地址空间,但又各自保存运行时所需状态(上下文)

## 多线程的地址空间布局
- 多线程地址空间的两个特性
  - 分离的内核栈和用户栈
  - 共享的其他区域

## 用户态线程与内核态线程
- 用户态线程
  - user-level thread
  - 应用创建,内核不可见
- 内核态线程
  - kernel-level thread
  - 内核创建,受操作系统调度器直接管理
- OS会建立用户态线程和内核态线程之间的关系,称其为`多线程模型`:
  - 多对一模式
  - 一对一模式
    - Linux和Windows系列的OS都是一对一模式
  - 多对多模式
![](https://i.imgur.com/VasJ22a.png)

## 线程控制块与线程本地存储
- `线程控制块`
  - Thread Control Block: `TCB`
  - 保存与线程相关的信息
  - pthread结构体就是`用户态的TCB`
- `线程本地存储`
  - Thread Local Storage:`TLS`
  - 实现`一个名字,多份拷贝`的全局变量
    - 当某个线程对count赋值时,只会修改自己的拷贝
  - x86-64使用`FS段寄存器`实现TLS中变量的`寻址`
