# 10.1 计算机设备的连接和通信

## 10.1.1 设备的连接: 总线
- bus
- 设备通过总线与 CPU 相连,常见的设备总线:
  - AMBA
  - PCIe
- 设备和总线的工作频率一般低于 CPU

### AMBA 总线
- 总线规范: `Adcanced Micro-controller Bus Architecture` 规范
  - 高级微控制器总线结构规范
- AMBA 总线规范一般包括三种总线:
  - `高级高性能总线`
    - Advanced High-Performen: `AHB`
    - 连接其他高性能 IP 核, 片上和片外内存 以及 中断控制器 等高性能模块
  - `高级系统总线`
    - Advanced System Bus: `ASB`
    - 不必使用 `AHB` 但又需要 `高性能`,可以部分 `降低功耗`
  - `高级设备总线`
    - Advanced Peripheral Bus: `APB`
    - 连接`低速`设备,降低功耗的`精简接口`
- 还包含`高级可扩展接口(Advanced eXtensible Interface: AXI)`
  - 高宽带,低延迟的片内总线

### PCI 总线
- 设备组件互联标准
  - Peripheral Component Interconnect: PCI
- PCIe
  - PCI express
  - 解决了数据传输速率过高时,PCI 所采用的并行线路之间会相互干扰

## 10.1.2 可编程I/O
- CPU 通常以读写设备寄存器的方式与设备进行通信
- 设备寄存器分为以下类型:
  - 控制寄存器: 接收来自驱动程序的命令
  - 状态寄存器: 反馈当前设备的工作状态
  - 输入/输出寄存器: 用于驱动和设备之间的数据交互
- 访问设备寄存器的两种方式:
  - `内存映射`
    - Memory-Mapped I/O: MMIO
  - `端口映射`
    - Port-Mapped I/O: PMIO
  - 这两种方式都称为`可编程I/O`
    - Programmed I/O: PIO

## 10.1.3 高效数据传输: DMA
- PIO 需要 CPU 主动搬运数据,大量 I/O 时会导致大量占用CPU
- 如何解放CPU?
  - 直接内存访问!!
- 直接内存访问:
  - Direct Memory Access: `DMA`
  - 在设备和内存之间主要且更高效的数据传输形式(设备与内存直接交互)
  - 允许设备`绕过`处理器直接读写系统内存的数据
  - 提高了处理器资源的利用率
- DMA的发起者:
  - `处理器`
  - `I/O设备`
  - 在一些总线中,DMA 的发起还需要 `DMA控制器` 的参与
    - `DMA 控制器`和`处理器`与内存连接到`同一系统总线(system bus)`
    - DMA 控制器相当于首发双方的第三方,称其为`第三方DMA`机制: `标准DMA`
  - 部分总线允许设备直接获取总线控制权并进行 DMA 操作
    - `第一方 DMA`
    - 如果多个设备希望同时进行DMA,总线控制器需进行仲裁，保证统一时间只允许一个设备进行 DMA

## 10.1.4 设备地址翻译: IOMMU
- 设备进行DMA时访问的内存地址是 `总线地址(bus address)`
  - 设备和内存之间的`输入输出内存管理单元(Input-Output Memory Management Unit: IOMMU)`负责将总线地址翻译为物理地址

# 10.2 设备的识别
- 常见机制为 `设备树` 与 `ACPI`
## 10.2.1 设备树
- 描述计算机硬件信息的数据结构 / 操作系统可读的硬件描述语言
  - 包含 CPU 的名称, 内存, 总线, 设备等硬件信息
- 如何使用
  - 设备树源码(Device Tree Source `DTS`)文件以文本形式描述了计算机系统设备的一个树状结构

## 10.2.2 ACPI
- 高级配置与电源接口: Advanced Configuration and Power Interface `ACPI`
- X86架构计算机上的标准设备识别方案
  - ACPI表
  - ACPI运行时:提供 AML 语言

- ACPI 与 设备树 的共通之处
  - 都使用树状结构对设备信息和层次关系进行描述
- 不同
  - 设备树描述的仅仅是一种 of 关系
  - ACPI 还可以控制设备行为
- 只有 X86 支持ACPI?
  - no
  - Linux同时支持两种

# 10.3 设备的中断
## 10.3.1 中断控制器
- 为什么引入中断控制器
  - CPU 轮询查询设备状态效率太低 -> 引入`中断`:让设备主动告知 CPU 一个外部事件的发生
  - 为了响应中断:实现`中断处理函数`
  - 没有中断控制器,限制太多 -> 引入`中断控制器`:管理新中断,为其安排不同优先级

## 10.3.2 中断的基本概念
- 以 GIC 中断处理器为例
#### 中断类型
- 软件生成中断
- 私有设备中断
- 共享设备中断

#### 中断优先级
高优先级中断会抢占低优先级中断

#### 中断号
- Interrupt ID: INTID

#### 中断状态
- Inactive:中断处于无效状态:此时中断还没有到来
- Pending:中断处于有效状态:中断已经发生,但 CPU 还没有响应
- Active: CPU处于响应并处理中断的过程中
- Active&Pending:CPU响应并处理中断的过程中,同时又有相应中断号的中断发生
![](https://i.imgur.com/gzoHELG.png)

#### 中断的响应过程
- Generate
- Deliver
- Activate
- Deactivate:CPU处理完中断,通知GIC中断处理完毕,GIC将中断更新为Inactive(中断完成:End Of Interrupt,`EOI`)

## 10.3.3 中断处理:以 Linux 上下半部的机制为例
- 为了及时响应,`Linux` 将中断处理过程分为两个阶段:
  - `上半部`:完成必要但轻量级的操作
    - 上半部分完成后立刻向中断控制器声明该中断已处理完毕,从而允许 CPU 继续处理中断
  - `下半部`:完成剩余的,复杂且时延要求相对低的操作
    - 下半部的执行时间由系统调度来确定
    - Linux 提供多种下半部的实现方式,下半部属于具有较高优先级的内核任务

- 硬中断处理函数又称为`中断服务例程`
  - 实质上为 Linux中断处理的上半部

#### Linux 常用的三种下半部机制
- 软中断
![](https://i.imgur.com/9AcLScX.png)
- tasklet
- 工作队列

![](https://i.imgur.com/ana5kD9.png)

# 10.4 设备驱动与设备驱动模型

## 10.4.1 设备驱动

## 10.4.2 设备驱动模型

# 10.5 Linux设备驱动模型
## 10.5.1 Linux的设备抽象
- 三种基本设备抽象
  - 字符设备
    - 将信息抽象为连续的字节流
    - 以字节粒度进行读写
  - 块设备
    - 以块的粒度进行读写
  - 网络设备
    - 数据单位为网络包

## 10.5.2 Linux的设备驱动模型
- 定义了四种基本的数据结构
  - 设备device: 抽象所有硬件
  - 驱动driver
  - 总线bus(Linux中所有的设备都要至少连接一条总线)
  - 类
![](https://i.imgur.com/6hq1hpB.png)


## 10.5.3 Linux驱动的动态管理

## 10.5.4 Linux的 sysfs文件系统

