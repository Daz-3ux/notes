# 镜像的内部机制
- 分层 `layer`
  - 容器内部由许多层镜像组成
  - 每层都是只读不修改的一组文件
  - 相同的层可在镜像之间共享
  - 多个层像积木一样堆叠起来使用:`Union FS 联合文件系统`

# Dockerfile
- 制作容器镜像的`施工图纸`
- Demo
```
# Dockerfile.busybox
FROM busybox
CMD echo "hello,world!"
```

# 如何编写正确,高效的 Dockerfile
- 需编写 Dockerfile,写清楚创建镜像的流程,每个指令都会生成一个 layer
- 第一个指令必须是 `FROM`,用来选择基础镜像.常用命令还有:
  - COPY
  - RUN
  - EXPOSE
  - CMD
- docker build
  - 需指定`构建上下文`
- 创建镜像时尽量使用 `-t` 参数取一个好名字

# Docker build 是怎么工作的
- FROM
  - 第一行指令必须是 FROM, 用来选择基础镜像
- COPY 指令
  - 需要打包进镜像的文件使用 COPY 命令复制进容器
  - 被复制文件必须在`构建上下文`路径里
- RUN 指令
  - 本质是 Shell 编程
  - 可以实现参数化运行
    - ARG 变量只在镜像构建过程可见
    - ENV 变量在容器运行时也能够以环境变量的形式被应用程序使用
- EXPOSE
  - 声明容器对外服务的端口号
    
**每个指令都会生成一个镜像层,所以不要滥用指令,尽量精简合并**

  容器镜像是由多个只读的 Layer 构成的,同一个 Layer 可以被不同的镜像共享

- 镜像里的层都是只读不可修改的，但容器运行的时候经常会写入数据，这个冲突应该怎么解决呢？
  - 容器最上一层是读写层,镜像所有层是只读层
  - 容器启动后, Docker daemon 会在容器的镜像上添加一个读写层