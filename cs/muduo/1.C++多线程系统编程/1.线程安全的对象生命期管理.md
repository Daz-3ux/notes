- Observer 设计模式
  - `观察者模式`
  - 当一个对象被修改时,则会自动通知依赖它的对象
  - 行为型模式

## 不会了的的概念
- **RAII**
  - Resource acquisition is initialization
  - 全局资源取得即初始化
- **可重入与不可重入**
  - 可重入函数: 可以被中断的函数
  - 不可重入函数: _不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的_
- **mutable**
  - 可变的
  - `mutable` 只能用来修饰类的数据成员,而被`mutable`修饰的数据成员,可以在`const`成员函数中修改
- **most-derived class**
  - 最晚派生类,层次最低的派生类
  - 析构函数能够且常常必须是虚函数。析构函数调用顺序与构造函数完全相反，从最晚派生类开始，依次向上到基类了;析构函数确切的知道它是从哪个类派生来的
- **空悬指针 / 野指针**
  - 空悬指针(dangling pointer): 指向已销毁的对象或以及回收的地址
  - 野指针(wild pointer): 指向未初始化的指针
- **boost:bind**
  - 标准库 std::bind1st 和 std::bind2nd 的一种泛化形式
  - 可以支持函数对象、函数、函数指针、成员函数指针，并且绑定任意参数到某个指定值上或者将输入参数传入任意位置

# 1.1 当析构函数遇到多线程
## 线程安全的定义
- 多个线程同时访问时,其表现出正确的行为
- 无论操作系统如何调度这些线程,无论这些线程的执行顺序如何交织
- 调用端代码无需额外的同步或其他协调动作

# 1.2 对象的创建很简单
## 对象的创建
- 对象构造要做到`线程安全`,唯一的要求就是在构造期间不要`泄漏 this 指针`:
  - 不要在构造函数中注册任何回调
  - 不要再构造函数中把 this 传给跨线程的对象
    - 即使是在构造函数的最后一行
- `二段式构造`有时会是好方法,虽然不符合C++教条
  - 构造函数 + initialize()

# 1.3 销毁太难
- `mutex`不是一个办法
  - 作为`class`数据成员的`mutexguard`只能用于同步本class的其他数据成员的读和写,不能安全的保护析构
  - 而且**析构过程不需要保护**,因为只有别的线程都访问不到这个对象时,析构才是安全的,否则容易出现竞态条件
  - 如果要同时读写一个class的两个对象,容易出现死锁

# 1.4 线程安全的 `Observer` 很难
- C/C++指针问题的根源:判断一个指针是不是一个合法指针没有高效的方法
- 在面向对象程序设计中,对象的关系主要有三种
  - `composition`:(组合/复合)
    - 对象x的生命期由唯一拥有者owner控制，owner析构时会把x同步析构
    - 例如Engine是Car的一部分。脱离Car的Engine是没有实在意义的，即表示Part-of 关系
  - `aggregation`:(聚合)
    - 例如Person有一个Address，但是Addess的存在是不依赖Person的，即表示Has-a关系
  - `association`:(关系/联系)
    - 它表示一个对象a用到了另一个对象b，即a持有b的指针（或引用），但是b的生命期不由a单独控制
- 使用`只创建不销毁`的方法:(池)
  - **问题**:
  - 对象池的线程安全
  - 全局共享数据引发的lock conection:集中化的对象池会不会把多线程并发的操作串行化
  - 共享对象的类型可能不止一种
  - 可能造成的内存泄漏与分片:池的内存只增不减

# 1.5 原始指针有何不妥
- 空悬指针
  - 万能解决方案: 
    - 引用另外一层间接性(`another layer of indirection`)
    - 用对象来管理共享资源
    - 作为一名谦卑的程序员,用线成的库就行

# 1.6 神器 `shared_ptr/weak_ptr`
- **shared_ptr**
  - 引用计数型智能指针
- **weak_ptr**
  - 弱引用:引用计数但`不增加对象的引用次数`
- 均为原子操作,没有用锁,性能非凡
- 效果:一旦某对象不再被引用,系统刻不容缓,立刻回收内存.通常发生在关键任务完成后的清理(clean up)时期,不会影响关键任务的实时性,同时,内存里所有的对象都是有用的,绝对没有垃圾空占内存.

# 1.7 插曲:系统地避免各种指针错误

# 1.8 应用到 Observer 上
- 很好用,但有一些问题
  - 侵入性
  - 不是完全线程安全
  - 锁争用
  - 死锁

# 1.9 再论 shared_ptr 的线程安全
- shared_ptr 本身不是百分百线程安全的
  - 它的引用计数本身是安全且无锁的
  - 但对象的读写不是
    - shared_ptr有两个数据成员,读写操作不能原子化
      - 一个是引用计数
      - 一个是指针
  - shared_ptr的线程安全级别和`内建类型,标准库容器,std::string`一样
    - 一个`sp`对象实体可被多个线程同时读取
    - 两个`sp`对象实体可以被两个线程同时写入,**"析构"算写操作**
    - 如果多个线程`读写`同一个shared_ptr对象,那么需要加锁

# 1.10 shared_ptr技术与陷阱
- 意外延长对象的生命期
- 函数参数
  - 使用pass by consy reference:性能高
- 析构动作在创建时被捕获
- 析构所在的线程
- 现成的 RAII handle
  - 一个不懂RAII的C++程序员不是一个合格的C++程序员
  - 每一个明确的`资源配置动作`(例如 new )都应在单一语句中执行,并在该语句中立刻将配置获得的资源交给 `handle` 对象(例如 shared_ptr),程序中一般**不出现** `delete`
  - shared_ptr 避免循环引用:
    - owner 持有指向 child 的 shared_ptr
    - child 持有指向 owner 的 weak_ptr

# 1.11 对象池
TH;DR
too hard,don't look

- `enable_shared_from_this`
  - 以派生类为模板类型实参的基类模板,继承它,this指针就可以变身为shared_ptr
- `弱回调`
  - 如果对象还活着,就调用它的成员函数,否则忽略之

# 1.12 替代方案


# 1.13 心得与小节
- "用流水线,生产者消费者,任务队列这些有规律的机制,最低限度地共享数据.是目前已知的最好的多线程编程建议了"
- 原始指针暴露给多个线程往往会造成 race condition 或 额外的记忆负担
- 统一用 shared_ptr/scoped_ptr 来管理对象的生命周期,在多线程尤其重要
- shared_ptr 是值语意,当心延长对象的生命期
- weak_ptr 是 shared_ptr 的好搭档,可以用作弱回调,对象池等
- 忘掉 auto_ptr 这个垃圾


# 1.14 Observer 之谬