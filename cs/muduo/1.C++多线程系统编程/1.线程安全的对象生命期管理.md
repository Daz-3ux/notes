- Observer 设计模式
  - `观察者模式`
  - 当一个对象被修改时,则会自动通知依赖它的对象
  - 行为型模式

## 不会了的的概念
- **RAII**
  - Resource acquisition is initialization
  - 全局资源取得即初始化
- **可重入与不可重入**
  - 可重入函数: 可以被中断的函数
  - 不可重入函数: _不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的_
- **mutable**
  - 可变的
  - `mutable` 只能用来修饰类的数据成员,而被`mutable`修饰的数据成员,可以在`const`成员函数中修改
- **most-derived class**
  - 最晚派生类,层次最低的派生类
  - 析构函数能够且常常必须是虚函数。析构函数调用顺序与构造函数完全相反，从最晚派生类开始，依次向上到基类了;析构函数确切的知道它是从哪个类派生来的
- **空悬指针 / 野指针**
  - 空悬指针(dangling pointer): 指向已销毁的对象或以及回收的地址
  - 野指针(wild pointer): 指向未初始化的指针

# 1.1 当析构函数遇到多线程
## 线程安全的定义
- 多个线程同时访问时,其表现出正确的行为
- 无论操作系统如何调度这些线程,无论这些线程的执行顺序如何交织
- 调用端代码无需额外的同步或其他协调动作

# 1.2 对象的创建很简单
## 对象的创建
- 对象构造要做到`线程安全`,唯一的要求就是在构造期间不要`泄漏 this 指针`:
  - 不要在构造函数中注册任何回调
  - 不要再构造函数中把 this 传给跨线程的对象
    - 即使是在构造函数的最后一行
- `二段式构造`有时会是好方法,虽然不符合C++教条
  - 构造函数 + initialize()

# 1.3 销毁太难
- `mutex`不是一个办法
  - 作为`class`数据成员的`mutexguard`只能用于同步本class的其他数据成员的读和写,不能安全的保护析构
  - 而且**析构过程不需要保护**,因为只有别的线程都访问不到这个对象时,析构才是安全的,否则容易出现竞态条件
  - 如果要同时读写一个class的两个对象,容易出现死锁

# 1.4 线程安全的 `Observer` 很难
- C/C++指针问题的根源:判断一个指针是不是一个合法指针没有高效的方法

