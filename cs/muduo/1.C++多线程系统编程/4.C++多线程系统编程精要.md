# C++ 多线程系统编程精要
- 学习多线程编程面临的最大的思维方式的转变有两点:
  - 当前线程可能随时会被切换出去,或者说是被`抢占(preempt)`了
  - 多线程程序中时间的发生顺序不再有全局统一的`先后关系`

## WTF
- `happens-before`
  - 前一个操作的结果对后续操作是可见的
- `cancellation point`
  - 取消点
  - 线程检查是否被取消并按照请求进行动作的一个位置
  - "鸡肋":最好不要从外部杀死线程
- `POD 类型`
  - Plain Old Data
  - C++ 定义的一类数据结构概念
  - 比如 int、float 等
  - 某某 class、struct、union 都不是 POD 类型

## 4.1 基本线程原语的选用
- 11 个常用的 POSIX thread 函数
  - 2个:线程的创建与等待结束(join)--封装为 `muduo:Thread`
  - 4个:mutex 的创建 销毁 加锁 解锁--封装为`muduo::MutexLock`
  - 5个:条件变量的创建 销毁 等待 通知 广播--封装为`muduo::Condition`

## 4.2 C/++ 系统库的线程安全性
- 有线程安全的函数,但组合使用后不见得依旧线程安全

## 4.3 Linux 上的线程标识
- pthread_t 并不适合用作程序中对线程的标识符
- 在 Linux 上,使用 `gettid()` 系统调用的返回值作为`线程 id`,好处有:
  - 其类型为 `pid_t`, 其值通常为小整数,便于查看
  - 在现代 Linux 中, 它直接表示内核的任务调度 id,可在 `/proc` 文件系统中找到对应项
  - 在其他系统工具中也容易定位到具体某一个线程
  - 任何时刻都是全局唯一的
  - 0 是非法值,因为操作系统的第一个进程 `init` 的 pid 为 1

## 4.4 线程的创建与销毁的守则
- 线程的`创建`只需要遵守:
  - 程序库不应该在未提前告知的情况下创建自己的"背景线程"
  - 尽量使用相同的方式创建线程,例如 `muduo::Thread`
  - 在进入 main() 之前不应该启动线程
  - 程序中线程的创建最好能在初始化阶段全部完成
- 线程的`销毁`:
  - 线程销毁的几种方式:
    - 自然死亡
    - 非正常死亡
    - 自杀
    - 他杀
  - 正常退出的方式只有一种:自然死亡
  - 如果确实需要强行终止一个线程,又不想周期性的检查某个全局退出变量:
    - 将那一部分代码 fork() 为新进程,这样的话杀一个进程比杀本进程内的线程安全得多
  - 如果一个线程可以做到“**程序中线程的创建最好能够在初始化阶段全部完成**”，则线程是不必销毁的，可以伴随进程一直运行

### 4.4.1 pthread_cancel 与 C++
- 还是不要从外部杀死线程了

### 4.4.2 exit(3) 在 C++ 中不是线程安全的
- 并非 exit() 的过错,二十全局对象析构的问题

## 4.5 善用 __thread 关键字
```c
int g_var; // 全局变量
__thread int t_var; // __thread 变量
```
- GCC 内置的`线程局部存储设施(thread local storage)`
- 使用规则
  - 只能用于修饰 `POD 类型`,不能修饰 class 类型,因为无法自动调用构造函数和析构函数
  - 可以用于修饰`全局变量`,`函数内的静态变量`,但是不能用于修饰函数的局部变量或class的普通成员变量
  - __thread 变量的初始化只能用`编译期常量`
- __thread变量在每一个线程中都有一份独立实例，各线程值是互不干扰的
- 还可以修饰那些"值可能会变,带有全局性,但是又不值得用全局锁保护"的变量

## 4.6 多线程与 IO

## 4.7 用 RAII 包装文件描述符

## 4.8 RAII 与 fork()

## 4.9 多线程与 fork()

## 4.10 多线程与 signal

## 4.11 Linux 新增系统调用的启示

## 小结