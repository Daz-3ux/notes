# 结构和联合

## 结构体

### 结构基础知识
1. 
- 聚合结构类型：能够同时存储超过一个的单独数据
- C语言提供**两种**聚合结构类型：数组，结构
- 结构是一些值的集合，这些值是它的**成员**
- 结构变量属于**标量变量**

2. 结构声明
- struct TAG {
 
}varible-list;

- typedef struct{
 
}Sample;
    - typedef可以创建一种新的类型，Sample是类型名
    - 可以将typedef形式的声明放到一个头文件中，方便后续使用

3. 结构成员
- 一个结构的成员的名字**可以**和其他结构的成员的名字**相同**

4. 结构成员的直接访问和间接访问
- (*sb).a = sb -> a; 

5. 结构体的自引用
- 
```
struct self{
    int a;
    struct self b;
}
```
是非法的
```
struct self{
    int a;
    struct self *b;
}
```
是合法的
    - 区别在于b在第一个里面是结构，会无限套娃；而在第二个里面是指针，可以自引用
    - 自引用在链表等很常见

6. 不完整的声明
- 声明一个相互依赖的结构
```c
struct B;

struct A {
    struct B *partner;
    ......
}

struct B{
    struct A *partner;
    ......
}

```

7. 结构体的初始化
- 类似多维数组，剩余的结构使用缺省值进行初始化

### 结构，指针和成员
1. 访问指针
```
EX x = {};
EX *px = &x;
```
- px是一个指针变量
- *px+1 非法： *px是一个结构，C语言并没有规定整型与结构相加的情况
- *（px+1） 非法 px不是标量，如果是数组x就可以，因为x是标量

### 结构的存储分配
- 字节对齐
- 并不是永远要字节对齐：例如数据较少时为了可读性
- sizeof（结构体）读的是结构的整个长度，包含被跳过的字节
- 若想确定结构某个成员具体位置，可使用offsetof宏(定义于stedef.h)
    - offsetof(struct SB,b); 



### 作为函数参数的结构
- 把结构作为参数传入合法但低效
- 传一个指向结构的指针就很高效，对栈温柔一点
- void print_receipt(register Transaction const *trans)
    - 寄存器
    - 防修改
    - 传指针
- 齐活了...

### 位段
- 位段声明必须为
```
int
signed
unsigned int
```
类型

- 缺：位段可移植性差，若考虑可移植则不要使用位段

- 优：
    - 能够把长度为奇数的数据包装在一起，节省存储空间【例硬盘中应用】
    - 源代码如果需要访问一个值内部的任意一些位，则使用位段比较方便



## 联合
1. 
- 联合中所有成员引用的是**内存中相同的位置**
```
union {
    float f;
    int i;
}fi;
```
- 联合的长度是其最长成员的长度

2. 变体记录
- 联合可以存指向不同变量的指针可以避免浪费，在使用时使用动态内存分配去初始化空间即可

3. 联合的初始化
- 联合可以被初始化，但这个初始值**必须是**联合的**第一个**成员的类型


### 联合基础知识

### 变体记录

### 联合的初始化