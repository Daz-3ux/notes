# 关于ANSI C标准

```c
int main(int argc, char** argv)
{
    char *cp;
    const char *cpp;
    cpp = cp;
    cp = cpp;//产生编译警告
}
```
运行以上小小代码，会发现编译器会关于注释行报错
初见此代码，会觉得cpp为被const修饰，应该为read-only
_(我们都知道，const并不能将变量变为常量，只是表示当前符号不能被赋值)_
而cp可以自由修改

但是，结果却与我们预期的不同

那么为什么会这样呢，这一切还是要从ANSI C标准里找出答案
- const char *类型并不是一个有限定符的类型，它的类型是“指向一个具有限定符的char类型的指针”，即const修饰的是指针所指向的类型，而不是指针本身(指针指向一个带有const限定符的char类型)

原来是这样，只有被指向的类型不可被赋值，而指针本身可以被改变

现在看来，我们已经可以理解cpp = cp，那么注释行的报错又要怎么解释呢？
- cp = cpp是指针的赋值运算
- 要想使其赋值形式合法，必须满足下列条件之一：
    - 两个操作数都是指向有限定符或无限定符的相容类型的指针
    - 左边指针所指向的类型**必须**具有右边指针所指类型的**全部限定符**
    - 左操作数是一个指向没有限定符的char的类型
    - 右操作数是一个指向指向有const限定符的char的指针
    - 左操作数并不具有右操作数所指向类型的限定符，**所以赋值失败**

到此，一切都通畅了起来
cpp = cp可以成功的逻辑即是：
- 左操作数所指向的类型具有右操作数所指向的类型的限定符（无：右边“无”限定符，将“无”限定符抽象为限定符：“无”）
- 左操作数再加上自身的限定符(const)