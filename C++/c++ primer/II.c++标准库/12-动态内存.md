终于是看完了，进没进脑袋就不知道了`2022.6.1`

# 12.1 动态内存和智能指针
- 虽然使用动态内存有时是必要的，但正确的管理动态内存老麻烦了
- 智能指针
    - shared_ptr
    - unique_prt
    - weak_ptr

## 12.1.1 shared_ptr
- 是模板
![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206012117383.png)

- make_shared()函数
    - `#include <memory>`
    - 最安全的分配和使用动态内存方法

- shared_ptr的拷贝和赋值
    - 一旦一个shared_ptr的计数器变为0, 它就会自动释放自己管理的对象

- shared_ptr自动销毁所管理的对象
    - 通过析构函数完成销毁

- shared_ptr还会自动释放相关联的内存
    - 对于一块内存,shared_ptr类保证只要有任何的shared_ptr对象引用它,它就不会被释放掉
    - 由于在最后一个shared_ptr销毁之前内存都不会释放,保证shared_ptr再无用之后不再保留就十分重要

- 使用了动态生存期的资源的类
    - 程序使用动态内存出于以下三种原因之一: 
    1. 程序不知道自己需要多少对象
    2. 程序不知道所需对象的准确类型
    3. 程序需要在多个对象间共享数据

## 12.1.2 直接管理内存
- `new`分配内存, `delete` 释放 new 分配的内存
- 使用智能指针的程序更容易编写与调试

- 使用new动态分配内存和初始化对象
    - 对动态分配的对象进行初始化通常是个好主意

- 动态分配的const对象
    - 用new分配 `const` 对象是合法的
    - 类似于其他任何const对象, 一个动态分配的 const对象 必须进行初始化

- 内存耗尽
    - 报错为 `bad_alloc`

- 释放动态内存
    - delete

- 指针值和delete
    - 虽然一个const对象的值不能被改变, 但它本身是可以被销毁的
    - 想要释放一个const动态对象, 只要delete指向它的指针即可

- 动态对象的生存期直到被释放为止
    - 展示一些基操:
    - 忘记delete
    - 使用已经释放的内存
    - 同一块内存释放两次

- delete之后要重置指针值
    - delete后指针变为空悬指针, 可以使其指向nullptr,安全

## 12.1.3 shared_ptr 和 new 结合使用
- 接受指针参数的智能指针构造函数是explicit的
- `shared_ptr<int> p2(new int(1024) )`
![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206012156537.png)

- 不要混合使用普通指针和智能指针

- 也不要使用get初始化另一个智能指针或为另一个智能指针赋值
    - get是用来将指针的访问权限传递给代码,你只有在确定代码不会delete指针的情况下才能使用get
    - 永远不要使用get初始化另一个智能指针或者为另外一个智能指针赋值

## 12.1.4 智能指针和异常
- 如果在 `new` 和 `delete` 之间发生异常,且异常未被捕获, 则内存就永远都不会被释放了

- 智能指针和哑类
    - 不懂

- 使用自己的释放操作
    - 当shared_ptr指向的对象不再是动态内存, 就可以自己定义一个函数来代替delete, 称其为 `删除器`

- 智能指针`陷阱`
![](https://raw.githubusercontent.com/Daz-3ux-Img/Img-hosting/master/202206012205175.png)


## 12.1.5 unique_ptr
