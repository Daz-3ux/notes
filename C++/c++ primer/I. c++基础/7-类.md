# intro
- 类的基本思想 **数据抽象** 和 **封装**
- 数据抽象：**interface**是一种依赖于 **接口与封装** **分离** 的编程技术
- 封装实现了类的接口和实现的分离

# 7.1 定义抽象数据类型
- tips：
    - c++程序员无需刻意区分应用程序的用户和类的用户，但在设计类时要考虑怎么才能使其简单易用，在使用类时不应顾及类的实现机理

## 定义成员函数
- 成员函数的**声明**必须在类的内部，其**定义**可以在类的内部也可以在类的外部
- 定义在类内部的函数是隐示的inline函数

## this
- 任何对类成员的直接访问都被看做this的隐式引用
- this形参是隐式定义的，任何自定义名为this的参数或变量都是非法的
- 在 C++ 中，每一个对象都能通过 `this` 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

## const成员函数
- const member function
- 我们不能在一个常量对象上调用普通的成员函数
- 常量对象，以及常量对象的引用和指针都只能调用常量成员函数

## 构造函数
- constructor
- 类通过一个或几个特殊的 **成员函数** 来控制其对象的初始化过程，这些函数叫做 **构造函数**
- 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数

### special
- 构造函数没有返回类型
- 类可以包含多个构造函数
- 不同的构造函数必须在参数数量与参数说明上有区别
- 构造函数不能别声明成const的，构造函数在const对象的构造过程中可以向其写值，直到构造函数完成初始化，此对象才可以真正获得其“常量”属性

### 合成的默认构造函数
- 默认构造函数：在没有构造函数的类中，类通过一个特殊的构造函数来控制默认初始化过程
- default constructor
- 默认构造函数无须任何参数
- 编译器创建的构造函数又被称作`合成的默认构造函数`
- synthesized default constructor
    - 合成的默认构造函数按以下规则初始化数据成员：
    - 如果存在类内的初始值，用它来初始化成员
    - 否则，默认初始化该成员

### 某些类不能依赖于合成的默认构造函数
- 合成的默认构造函数只适用于非常简单的类
- 一个普通的类必须定义自己的默认构造函数：
    1. 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数
    2. 如果类包含有内置类型或者符合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适用于使用合成的默认构造函数
    3. 编译器不能为某些类合成默认的构造函数

### 定义构造函数
```cpp
struct Sales_data {
    Sales_data() =default;

    Sales_data(const std::string &s) : bookNo(s) { };

    Sales_data(const std::string &s, unsigned n, double p) : 
    bookNo(s), units_sold(n), revenue(p*n) { };

    Sales_data(std::istream &);
}
```
- 在类的外部定义构造函数
```cpp
Sales_data::Sales_data(std::istream &is){
    read(is, *this);
}
```

### 拷贝，赋值与析构
- 除初始化外，类还需控制拷贝，赋值和销毁对象时发生的行为
- 如果我们不主动定义这些操作，则编译器会替我们合成它们

#### 某些类不能依赖于合成的版本
- 例如，当类需要分配类对象之外的资源时，合成的版本常常失效
- 很多需要动态内存的类能(**应该**)使用vector对象或者string对象管理必要的存储空间，使用vector或者string能 **避免分配和释放内存带来的复杂性**：
    - 若类包含vector或者string成员，则其拷贝，赋值和销毁的 **合成版本** 可以正常工作：
    - 当我们对含有vector成员的对象执行拷贝或赋值：vector类会设法拷贝或者赋值成员中的元素，当这样的对象被销毁时，将销毁vector对象，也就是依次销毁vector中的每一个元素：与string类似


# 7.2 访问控制与封装
- 加强类的封装性：使用访问说明符
- `access specifiers`
- 定义在`public`后：说明符之后的成员在整个程序内可被访问
- 定义在`private`后：说明符之后的成员可以被类的成员函数访问，其封装了类的实现
- 一个类可以有0到多个访问说明符

## 使用class或struct关键字
- 唯一区别是 **默认访问权限** 不同
- struct：定义在第一个访问说明符之前的成员是public的
- class：定义在第一个访问说明符之前的成员是private的

## 友元
- 类可以允许其他类或函数访问它的非公有成员，方法是令其他类或函数成为它的**友元**；
- `friend`关键字
- 最好在类定义开始或结束前的位置集中说明友元
- 友元的声明只是指定了访问的权限，而不是通常意义上的函数声明

# 7.3 类的其他特性
## 重载成员函数
成员函数也可以重载

## 可变数据成员
- mutable data member
- 永远不会是const，即使其是const对象的成员

## 从const成员函数返回*this
一个const成员函数如果以引用的形式返回*this， 那么它的返回类型将是常量引用

## 类类型
即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和其他任何类(或者任何其他作用域)的成员都不是一回事

## 类的声明
```cpp
class Screen;//前向声明
```
- 对于Screen，在其 **声明后定义前** 是一个`不完全类型`：我们已知Screen是一个类类型，但不知道其包含哪些成员

- 一旦一个类的名字出现后，它就被认为是声明过了(但未定义)，因此类允许包含指向它自身类型的引用或指针

# 7.4 类的作用域
- 每个类都会定义自己的作用域，一个类就是一个作用域
- 函数的返回类型都位于类的作用域之外，返回类型必须指明它是哪个类的成员(::)

## 名字查找与类的作用域
### 名字查找：name lookup：
- 首先在名字所在块中查找其声明语句，只考虑在名字的使用之前出现的语句
- 如果没找到则继续查找外层作用域
- 如果没找到匹配的声明则报错

#### 对于定义在类中的成员函数其查找规则与以上有所区别
- 首先编译成员的声明
- 直到类完全可见后才编译函数体

--编译器处理完类中的全部声明后才会处理成员函数的定义

# 7.5 构造函数再探
- 建议养成使用构造函数初始化的习惯，这样可以避免意想不到的编译错误：有的数据成员必须初始化且有的类含有需要构造函数初始化的成员
- 构造函数初始化的顺序最好与成员声明的顺序保持一致

## 委托构造函数
- delegating constructor
- 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程：其将自己的一些(或全部)职责委托给了其他构造函数

## 聚合类
- 用户可以直接访问其成员
    - 所有成员都是public的
    - 没有定义任何构造函数
    - 没有类内初始值
    - 没有基类，也没有virtual函数

- 数据成员都是字面值类型的聚合类是字面值常量

