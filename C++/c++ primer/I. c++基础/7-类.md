# intro
- 类的基本思想 **数据抽象** 和 **封装**
- 数据抽象：**interface**是一种依赖于 **接口与封装** **分离** 的编程技术
- 封装实现了类的接口和实现的分离

# 7.1 定义抽象数据类型
- tips：
    - c++程序员无需刻意区分应用程序的用户和类的用户，但在设计类时要考虑怎么才能使其简单易用，在使用类时不应顾及类的实现机理

## 定义成员函数
- 成员函数的**声明**必须在类的内部，其**定义**可以在类的内部也可以在类的外部
- 定义在类内部的函数是隐示的inline函数

## this
- 任何对类成员的直接访问都被看做this的隐式引用
- this形参是隐式定义的，任何自定义名为this的参数或变量都是非法的
- 在 C++ 中，每一个对象都能通过 `this` 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

## const成员函数
- const member function
- 我们不能在一个常量对象上调用普通的成员函数
- 常量对象，以及常量对象的引用和指针都只能调用常量成员函数

## 构造函数
- constructor
- 类通过一个或几个特殊的 **成员函数** 来控制其对象的初始化过程，这些函数叫做 **构造函数**
- 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数

### special
- 构造函数没有返回类型
- 类可以包含多个构造函数
- 不同的构造函数必须在参数数量与参数说明上有区别
- 构造函数不能别声明成const的，构造函数在const对象的构造过程中可以向其写值，直到构造函数完成初始化，此对象才可以真正获得其“常量”属性

### 合成的默认构造函数
- 默认构造函数：在没有构造函数的类中，类通过一个特殊的构造函数来控制默认初始化过程
- default constructor
- 默认构造函数无须任何参数
- 编译器创建的构造函数又被称作`合成的默认构造函数`
- synthesized default constructor
    - 合成的默认构造函数按以下规则初始化数据成员：
    - 如果存在类内的初始值，用它来初始化成员
    - 否则，默认初始化该成员

### 某些类不能依赖于合成的默认构造函数
- 合成的默认构造函数只适用于非常简单的类
- 一个普通的类必须定义自己的默认构造函数：
    1. 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数
    2. 如果类包含有内置类型或者符合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适用于使用合成的默认构造函数
    3. 编译器不能为某些类合成默认的构造函数

### 定义构造函数
```cpp
struct Sales_data {
    Sales_data() =default;

    Sales_data(const std::string &s) : bookNo(s) { };

    Sales_data(const std::string &s, unsigned n, double p) : 
    bookNo(s), units_sold(n), revenue(p*n) { };

    Sales_data(std::istream &);
}
```
- 在类的外部定义构造函数
```cpp
Sales_data::Sales_data(std::istream &is){
    read(is, *this);
}
```

### 拷贝，赋值与析构
- 除初始化外，类还需控制拷贝，赋值和销毁对象时发生的行为
- 如果我们不主动定义这些操作，则编译器会替我们合成它们

#### 某些类不能依赖于合成的版本
- 例如，当类需要分配类对象之外的资源时，合成的版本常常失效
- 很多需要动态内存的类能(**应该**)使用vector对象或者string对象管理必要的存储空间，使用vector或者string能 **避免分配和释放内存带来的复杂性**：
    - 若类包含vector或者string成员，则其拷贝，赋值和销毁的 **合成版本** 可以正常工作：
    - 当我们对含有vector成员的对象执行拷贝或赋值：vector类会设法拷贝或者赋值成员中的元素，当这样的对象被销毁时，将销毁vector对象，也就是依次销毁vector中的每一个元素：与string类似